# --- injected: analysis sidecar synthesis from packager.yml -------------------\n# After the normal run completes, append empty-but-valid analysis summaries for\n# families whose emission mode is "both". We write them as 'file' records into\n# the JSONL manifest so downstream checksum/publisher behavior is unchanged.\ntry:\n    import json as _json, base64 as _b64, hashlib as _hashlib\n    from pathlib import Path as _P\n    try:\n        import yaml as _yaml  # optional\n    except Exception:  # pragma: no cover\n        _yaml = None  # type: ignore\n\n    def _pm__resolve_class():\n        for _name in ("Packager", "Orchestrator"):\n            _cls = globals().get(_name)\n            if _cls is not None and hasattr(_cls, "run"):\n                return _cls\n        return None\n\n    def _pm__read_packager_dict(repo_root: _P) -> dict:\n        if _yaml is None:\n            return {}\n        p = (repo_root / "config" / "packager.yml")\n        if not p.exists():\n            return {}\n        try:\n            return _yaml.safe_load(p.read_text(encoding="utf-8")) or {}\n        except Exception:\n            return {}\n\n    def _pm__plan_from_cfg(cfg) -> tuple[list[str], dict[str, str], bool]:\n        # Returns (families_to_emit, filename_map, synthesize_flag)\n        try:\n            repo_root = _P(str(getattr(cfg, "repo_root", ".")))\n        except Exception:\n            repo_root = _P(".").resolve()\n        data = _pm__read_packager_dict(repo_root)\n        emission = dict((data.get("metadata_emission") or {}))\n        filenames = dict((data.get("analysis_filenames") or {}))\n        controls = dict((data.get("controls") or {}))\n        synth = bool(controls.get("synthesize_empty_summaries", True))\n\n        defaults = {\n            "asset": "asset.summary.json",\n            "deps": "deps.index.summary.json",\n            "sbom": "sbom.cyclonedx.json",\n            "entrypoints": "entrypoints.summary.json",\n            "env": "env.summary.json",\n            "git": "git.info.summary.json",\n            "io_core": "manifest.summary.json",\n            "license": "license.summary.json",\n            "secrets": "secrets.summary.json",\n            "sql": "sql.index.summary.json",\n            "ast_symbols": "ast.symbols.summary.json",\n            "ast_imports": "ast.imports.summary.json",\n            "ast_calls": "ast.calls.summary.json",\n            "docs": "docs.coverage.summary.json",\n            "quality": "quality.complexity.summary.json",\n            "html": "html.summary.json",\n            "js": "js.index.summary.json",\n            "cs": "cs.summary.json",\n            "codeowners": "codeowners.summary.json",\n        }\n        for k, v in defaults.items():\n            filenames.setdefault(k, v)\n\n        fams = [k for k, v in emission.items() if str(v).lower() == "both"]\n        return fams, filenames, synth\n\n    def _pm__derive_files_scanned(manifest_path: _P) -> int:\n        try:\n            for ln in manifest_path.read_text(encoding="utf-8", errors="replace").splitlines():\n                if '"path": "analysis/contents_index.json"' in ln:\n                    rec = _json.loads(ln)\n                    raw = _b64.b64decode(rec.get("content_b64") or "")\n                    arr = _json.loads(raw.decode("utf-8"))\n                    return int(len(arr))\n        except Exception:\n            pass\n        return 0\n\n    def _pm__append_sidecars(manifest_path: _P, sidecars: dict[str, dict]) -> int:\n        # Append JSONL lines to manifest_path (each 'file' record)\n        if not manifest_path.exists():\n            return 0\n        # Avoid duplicating sidecars if re-run\n        existing = set()\n        try:\n            for ln in manifest_path.read_text(encoding="utf-8", errors="replace").splitlines():\n                if '"type": "file"' in ln and '"path": "analysis/' in ln:\n                    try:\n                        rec = _json.loads(ln)\n                        p = rec.get("path")\n                        if isinstance(p, str):\n                            existing.add(p)\n                    except Exception:\n                        pass\n        except Exception:\n            pass\n\n        added = 0\n        with manifest_path.open("a", encoding="utf-8") as f:\n            for rel_path, obj in sidecars.items():\n                if rel_path in existing:\n                    continue\n                payload = _json.dumps(obj, ensure_ascii=False, sort_keys=True, indent=2).encode("utf-8")\n                rec = {\n                    "type": "file",\n                    "path": rel_path,\n                    "content_b64": _b64.b64encode(payload).decode("ascii"),\n                    "sha256": _hashlib.sha256(payload).hexdigest(),\n                }\n                f.write(_json.dumps(rec, ensure_ascii=False) + "\n")\n                added += 1\n        return added\n\n    _PM_TARGET_CLS = _pm__resolve_class()\n    if _PM_TARGET_CLS is not None:\n        _PM_ORIG_RUN = getattr(_PM_TARGET_CLS, "run", None)\n\n        def _pm__patched_run(self, external_source=None):\n            # Execute original behavior\n            result = _PM_ORIG_RUN(self, external_source)\n            try:\n                fams, filenames, synth = _pm__plan_from_cfg(self.cfg)\n                if not synth or not fams:\n                    return result\n                files_scanned = _pm__derive_files_scanned(self.cfg.out_bundle)\n                sidecars: dict[str, dict] = {}\n                for fam in fams:\n                    name = filenames.get(fam) or f"{fam}.summary.json"\n                    rel = f"analysis/{name}"\n                    sidecars[rel] = {\n                        "kind": str(fam),\n                        "files_scanned": int(files_scanned),\n                        "generated_by": "packager:pm_synth",\n                        "timestamp": None,\n                        "records": [],\n                    }\n                added = _pm__append_sidecars(self.cfg.out_bundle, sidecars)\n                if added:\n                    try:\n                        _log(f"Analysis: synthesized {added} empty summary file(s) per packager.yml")\n                    except Exception:\n                        pass\n            except Exception as e:\n                try:\n                    _log(f"Analysis: synthesize skipped: {type(e).__name__}: {e}")\n                except Exception:\n                    pass\n            return result\n\n        # Install wrapper once\n        if callable(_PM_ORIG_RUN) and not getattr(_PM_ORIG_RUN, "_pm_wrapped", False):\n            setattr(_PM_TARGET_CLS, "run", _pm__patched_run)\n            try:\n                setattr(getattr(_PM_TARGET_CLS, "run"), "_pm_wrapped", True)\n            except Exception:\n                pass\n        else:\n            try:\n                _log("Init: analysis sidecar synthesis already installed or run() not callable")\n            except Exception:\n                pass\n    else:\n        try:\n            _log("Init: Packager/Orchestrator class not found; sidecar synthesis not installed")\n        except Exception:\n            pass\nexcept Exception as _pm_ex:\n    try:\n        _log(f"Init: analysis sidecar synthesis failed: {type(_pm_ex).__name__}: {_pm_ex}")\n    except Exception:\n        pass\n# --- end injected -------------------------------------------------------------