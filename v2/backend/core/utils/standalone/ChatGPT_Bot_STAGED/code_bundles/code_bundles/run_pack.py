# --- injected: build_cfg wrapper to read packager.yml -------------------------\n# Appends minimal configuration fields to cfg returned by build_cfg(), without\n# touching existing code paths. Safe if packager.yml is absent.\ntry:\n    from pathlib import Path as _P\n    try:\n        import yaml as _pm_yaml  # optional\n    except Exception:  # pragma: no cover\n        _pm_yaml = None  # type: ignore\n\n    # Resolve repo root in a way consistent with this module, if available.\n    def _pm__detect_repo_root(cfg=None):\n        try:\n            # If run_pack defines ConfigPaths, use it\n            CP = globals().get("ConfigPaths")\n            if CP is not None:\n                return CP.detect().repo_root\n        except Exception:\n            pass\n        try:\n            if cfg is not None and hasattr(cfg, "repo_root"):\n                return _P(str(cfg.repo_root))\n        except Exception:\n            pass\n        # Fallback to module dirâ€™s parent (project root expectation)\n        return _P(__file__).resolve().parents[4]\n\n    def _pm__read_packager_dict(repo_root: _P) -> dict:\n        if _pm_yaml is None:\n            return {}\n        p = (repo_root / "config" / "packager.yml")\n        if not p.exists():\n            return {}\n        try:\n            return _pm_yaml.safe_load(p.read_text(encoding="utf-8")) or {}\n        except Exception:\n            return {}\n\n    _PM_ORIG_BUILD_CFG = globals().get("build_cfg")\n\n    def _pm__wrapped_build_cfg(*a, **kw):\n        # Call original builder first\n        cfg = _PM_ORIG_BUILD_CFG(*a, **kw) if callable(_PM_ORIG_BUILD_CFG) else None\n        if cfg is None:\n            return cfg\n        try:\n            repo_root = _pm__detect_repo_root(cfg)\n            data = _pm__read_packager_dict(repo_root)\n            for _k in ("metadata_emission", "analysis_filenames", "family_aliases", "controls"):\n                _v = data.get(_k)\n                setattr(cfg, _k, _v if isinstance(_v, dict) else {})\n        except Exception:\n            # Keep cfg unchanged on any error\n            pass\n        return cfg\n\n    # Install wrapper once\n    if callable(_PM_ORIG_BUILD_CFG) and not getattr(_PM_ORIG_BUILD_CFG, "_pm_wrapped", False):\n        globals()["build_cfg"] = _pm__wrapped_build_cfg\n        try:\n            setattr(globals()["build_cfg"], "_pm_wrapped", True)\n        except Exception:\n            pass\nexcept Exception:\n    # Non-fatal: leave original behavior\n    pass\n# --- end injected -------------------------------------------------------------