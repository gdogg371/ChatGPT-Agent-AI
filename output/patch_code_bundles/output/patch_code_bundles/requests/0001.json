{
  "provider": "openai",
  "model": "gpt-4o-mini",
  "messages": [
    {
      "role": "system",
      "content": "__assistant_handoff.v1.json__\n\n\n__design_manifest.jsonl__\n\n\n"
    },
    {
      "role": "system",
      "content": "You are a precise Python documentation assistant.\nWrite PEP 257–compliant docstrings that are specific and useful.\nRules:\n  - NEVER return placeholders like 'Add a concise summary', 'TBD', 'TODO', or empty strings.\n  - First line: short imperative summary.\n  - Then a blank line, then details.\n  - For functions: include Args (names/types if visible), Returns, Raises (if any).\n  - For classes: purpose, key attributes/behaviors, noteworthy methods.\n  - For modules: describe what the module provides, key components, and how it fits in the package.\n  - Be faithful to the provided code/context; if something is unknown, omit it.\n  - Output ONLY JSON as requested; no extra prose.\n"
    },
    {
      "role": "user",
      "content": "For each item below, return a JSON list like:\n[{\"id\": \"<id>\", \"docstring\": \"<PEP257 docstring>\"}]\nConstraints:\n  - 'docstring' MUST be non-empty and meaningful (≈20+ words unless the symbol is trivial).\n  - Do NOT include triple quotes; return just the string content.\n  - If the symbol is a module and code is sparse, still write a helpful module docstring:\n    summarize the module's purpose using file path, names seen, and imports (do not invent APIs).\nItems:\n\n--\nid: 1808\nmode: rewrite\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n\"\"\"Core primitives: errors, types, budget, logs.\"\"\"\n```\n--\nid: 1807\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n# File: v2/patches/executor/run_patch_loop_local.py\n#!/usr/bin/env python3\nfrom __future__ import annotations\n\n\"\"\"\nLocal, PyCharm-friendly entrypoint for the patch loop — now routed via the Spine.\n\nFlow (configurable by flags):\n  1) Build PatchLoopConfig-style payload from CLI\n  2) Ask Spine to run the LLM pipeline (capability: llm.engine.run.v1) [--only-apply to skip]\n  3) Gather *.patch files from the **run directory only** (no global drop-zones)\n  4) Ask Spine to apply patches (capability: patch.apply_files.v1)\n\nNo DB schema changes. No Git usage for patch application.\nAll patch/mirror/workspace artifacts live **inside the run directory**.\n\"\"\"\n\nimport argparse\nimport importlib.util\nimport os\nimport re\nimport sys\nfrom pathlib import Path\nfrom typing import Any, Dict, List, Optional\n\n# --- Spine bus -----------------------------------------------------------------\n```\n--\nid: 1806\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n# File: v2/patches/executor/run_patch_loop_local.py\n#!/usr/bin/env python3\nfrom __future__ import annotations\n\n\"\"\"\nLocal, PyCharm-friendly entrypoint for the patch loop — now routed via the Spine.\n\nFlow (configurable by flags):\n  1) Build PatchLoopConfig-style payload from CLI\n  2) Ask Spine to run the LLM pipeline (capability: llm.engine.run.v1) [--only-apply to skip]\n  3) Gather *.patch files from the **run directory only** (no global drop-zones)\n  4) Ask Spine to apply patches (capability: patch.apply_files.v1)\n\nNo DB schema changes. No Git usage for patch application.\nAll patch/mirror/workspace artifacts live **inside the run directory**.\n\"\"\"\n\nimport argparse\nimport importlib.util\nimport os\nimport re\nimport sys\nfrom pathlib import Path\nfrom typing import Any, Dict, List, Optional\n\n# --- Spine bus -----------------------------------------------------------------\n```\n--\nid: 1805\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n# File: v2/patches/executor/run_patch_loop_local.py\n#!/usr/bin/env python3\nfrom __future__ import annotations\n\n\"\"\"\nLocal, PyCharm-friendly entrypoint for the patch loop — now routed via the Spine.\n\nFlow (configurable by flags):\n  1) Build PatchLoopConfig-style payload from CLI\n  2) Ask Spine to run the LLM pipeline (capability: llm.engine.run.v1) [--only-apply to skip]\n  3) Gather *.patch files from the **run directory only** (no global drop-zones)\n  4) Ask Spine to apply patches (capability: patch.apply_files.v1)\n\nNo DB schema changes. No Git usage for patch application.\nAll patch/mirror/workspace artifacts live **inside the run directory**.\n\"\"\"\n\nimport argparse\nimport importlib.util\nimport os\nimport re\nimport sys\nfrom pathlib import Path\nfrom typing import Any, Dict, List, Optional\n\n# --- Spine bus -----------------------------------------------------------------\n```\n--\nid: 1804\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n# File: v2/patches/executor/run_patch_loop_local.py\n#!/usr/bin/env python3\nfrom __future__ import annotations\n\n\"\"\"\nLocal, PyCharm-friendly entrypoint for the patch loop — now routed via the Spine.\n\nFlow (configurable by flags):\n  1) Build PatchLoopConfig-style payload from CLI\n  2) Ask Spine to run the LLM pipeline (capability: llm.engine.run.v1) [--only-apply to skip]\n  3) Gather *.patch files from the **run directory only** (no global drop-zones)\n  4) Ask Spine to apply patches (capability: patch.apply_files.v1)\n\nNo DB schema changes. No Git usage for patch application.\nAll patch/mirror/workspace artifacts live **inside the run directory**.\n\"\"\"\n\nimport argparse\nimport importlib.util\nimport os\nimport re\nimport sys\nfrom pathlib import Path\nfrom typing import Any, Dict, List, Optional\n\n# --- Spine bus -----------------------------------------------------------------\n```\n--\nid: 1803\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n# File: v2/patches/executor/run_patch_loop_local.py\n#!/usr/bin/env python3\nfrom __future__ import annotations\n\n\"\"\"\nLocal, PyCharm-friendly entrypoint for the patch loop — now routed via the Spine.\n\nFlow (configurable by flags):\n  1) Build PatchLoopConfig-style payload from CLI\n  2) Ask Spine to run the LLM pipeline (capability: llm.engine.run.v1) [--only-apply to skip]\n  3) Gather *.patch files from the **run directory only** (no global drop-zones)\n  4) Ask Spine to apply patches (capability: patch.apply_files.v1)\n\nNo DB schema changes. No Git usage for patch application.\nAll patch/mirror/workspace artifacts live **inside the run directory**.\n\"\"\"\n\nimport argparse\nimport importlib.util\nimport os\nimport re\nimport sys\nfrom pathlib import Path\nfrom typing import Any, Dict, List, Optional\n\n# --- Spine bus -----------------------------------------------------------------\n```\n--\nid: 1802\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n# File: v2/patches/executor/run_patch_loop_local.py\n#!/usr/bin/env python3\nfrom __future__ import annotations\n\n\"\"\"\nLocal, PyCharm-friendly entrypoint for the patch loop — now routed via the Spine.\n\nFlow (configurable by flags):\n  1) Build PatchLoopConfig-style payload from CLI\n  2) Ask Spine to run the LLM pipeline (capability: llm.engine.run.v1) [--only-apply to skip]\n  3) Gather *.patch files from the **run directory only** (no global drop-zones)\n  4) Ask Spine to apply patches (capability: patch.apply_files.v1)\n\nNo DB schema changes. No Git usage for patch application.\nAll patch/mirror/workspace artifacts live **inside the run directory**.\n\"\"\"\n\nimport argparse\nimport importlib.util\nimport os\nimport re\nimport sys\nfrom pathlib import Path\nfrom typing import Any, Dict, List, Optional\n\n# --- Spine bus -----------------------------------------------------------------\n```\n--\nid: 1801\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n# File: v2/patches/executor/run_patch_loop_local.py\n#!/usr/bin/env python3\nfrom __future__ import annotations\n\n\"\"\"\nLocal, PyCharm-friendly entrypoint for the patch loop — now routed via the Spine.\n\nFlow (configurable by flags):\n  1) Build PatchLoopConfig-style payload from CLI\n  2) Ask Spine to run the LLM pipeline (capability: llm.engine.run.v1) [--only-apply to skip]\n  3) Gather *.patch files from the **run directory only** (no global drop-zones)\n  4) Ask Spine to apply patches (capability: patch.apply_files.v1)\n\nNo DB schema changes. No Git usage for patch application.\nAll patch/mirror/workspace artifacts live **inside the run directory**.\n\"\"\"\n\nimport argparse\nimport importlib.util\nimport os\nimport re\nimport sys\nfrom pathlib import Path\nfrom typing import Any, Dict, List, Optional\n\n# --- Spine bus -----------------------------------------------------------------\n```\n--\nid: 1800\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n# File: v2/patches/executor/run_patch_loop_local.py\n#!/usr/bin/env python3\nfrom __future__ import annotations\n\n\"\"\"\nLocal, PyCharm-friendly entrypoint for the patch loop — now routed via the Spine.\n\nFlow (configurable by flags):\n  1) Build PatchLoopConfig-style payload from CLI\n  2) Ask Spine to run the LLM pipeline (capability: llm.engine.run.v1) [--only-apply to skip]\n  3) Gather *.patch files from the **run directory only** (no global drop-zones)\n  4) Ask Spine to apply patches (capability: patch.apply_files.v1)\n\nNo DB schema changes. No Git usage for patch application.\nAll patch/mirror/workspace artifacts live **inside the run directory**.\n\"\"\"\n\nimport argparse\nimport importlib.util\nimport os\nimport re\nimport sys\nfrom pathlib import Path\nfrom typing import Any, Dict, List, Optional\n\n# --- Spine bus -----------------------------------------------------------------\n```\n--\nid: 1799\nmode: create\nsignature: module\ndescription: Pick a default inscope seed dir under project_root for the mirror.\ncontext_code:\n```python\n# File: v2/patches/executor/run_patch_loop_local.py\n#!/usr/bin/env python3\nfrom __future__ import annotations\n\n\"\"\"\nLocal, PyCharm-friendly entrypoint for the patch loop — now routed via the Spine.\n\nFlow (configurable by flags):\n  1) Build PatchLoopConfig-style payload from CLI\n  2) Ask Spine to run the LLM pipeline (capability: llm.engine.run.v1) [--only-apply to skip]\n  3) Gather *.patch files from the **run directory only** (no global drop-zones)\n  4) Ask Spine to apply patches (capability: patch.apply_files.v1)\n\nNo DB schema changes. No Git usage for patch application.\nAll patch/mirror/workspace artifacts live **inside the run directory**.\n\"\"\"\n\nimport argparse\nimport importlib.util\nimport os\nimport re\nimport sys\nfrom pathlib import Path\nfrom typing import Any, Dict, List, Optional\n\n# --- Spine bus -----------------------------------------------------------------\n```\n--\nid: 1798\nmode: create\nsignature: module\ndescription: Use CLI, env, loader, or YAML to resolve the OpenAI API key.\ncontext_code:\n```python\n# File: v2/patches/executor/run_patch_loop_local.py\n#!/usr/bin/env python3\nfrom __future__ import annotations\n\n\"\"\"\nLocal, PyCharm-friendly entrypoint for the patch loop — now routed via the Spine.\n\nFlow (configurable by flags):\n  1) Build PatchLoopConfig-style payload from CLI\n  2) Ask Spine to run the LLM pipeline (capability: llm.engine.run.v1) [--only-apply to skip]\n  3) Gather *.patch files from the **run directory only** (no global drop-zones)\n  4) Ask Spine to apply patches (capability: patch.apply_files.v1)\n\nNo DB schema changes. No Git usage for patch application.\nAll patch/mirror/workspace artifacts live **inside the run directory**.\n\"\"\"\n\nimport argparse\nimport importlib.util\nimport os\nimport re\nimport sys\nfrom pathlib import Path\nfrom typing import Any, Dict, List, Optional\n\n# --- Spine bus -----------------------------------------------------------------\n```\n--\nid: 1797\nmode: create\nsignature: module\ndescription: Extract OpenAI API key from secrets dict.\ncontext_code:\n```python\n# File: v2/patches/executor/run_patch_loop_local.py\n#!/usr/bin/env python3\nfrom __future__ import annotations\n\n\"\"\"\nLocal, PyCharm-friendly entrypoint for the patch loop — now routed via the Spine.\n\nFlow (configurable by flags):\n  1) Build PatchLoopConfig-style payload from CLI\n  2) Ask Spine to run the LLM pipeline (capability: llm.engine.run.v1) [--only-apply to skip]\n  3) Gather *.patch files from the **run directory only** (no global drop-zones)\n  4) Ask Spine to apply patches (capability: patch.apply_files.v1)\n\nNo DB schema changes. No Git usage for patch application.\nAll patch/mirror/workspace artifacts live **inside the run directory**.\n\"\"\"\n\nimport argparse\nimport importlib.util\nimport os\nimport re\nimport sys\nfrom pathlib import Path\nfrom typing import Any, Dict, List, Optional\n\n# --- Spine bus -----------------------------------------------------------------\n```\n--\nid: 1796\nmode: create\nsignature: module\ndescription: \"Derive a default project root for local IDE runs that contains the databases folder.\"\ncontext_code:\n```python\n# File: v2/patches/executor/run_patch_loop_local.py\n#!/usr/bin/env python3\nfrom __future__ import annotations\n\n\"\"\"\nLocal, PyCharm-friendly entrypoint for the patch loop — now routed via the Spine.\n\nFlow (configurable by flags):\n  1) Build PatchLoopConfig-style payload from CLI\n  2) Ask Spine to run the LLM pipeline (capability: llm.engine.run.v1) [--only-apply to skip]\n  3) Gather *.patch files from the **run directory only** (no global drop-zones)\n  4) Ask Spine to apply patches (capability: patch.apply_files.v1)\n\nNo DB schema changes. No Git usage for patch application.\nAll patch/mirror/workspace artifacts live **inside the run directory**.\n\"\"\"\n\nimport argparse\nimport importlib.util\nimport os\nimport re\nimport sys\nfrom pathlib import Path\nfrom typing import Any, Dict, List, Optional\n\n# --- Spine bus -----------------------------------------------------------------\n```\n--\nid: 1795\nmode: create\nsignature: module\ndescription: \"Find first database file 'databases/bot_dev.db' in directory hierarchy starting from 'start' and return directory containing it, or CWD if not found.\"\ncontext_code:\n```python\n# File: v2/patches/executor/run_patch_loop_local.py\n#!/usr/bin/env python3\nfrom __future__ import annotations\n\n\"\"\"\nLocal, PyCharm-friendly entrypoint for the patch loop — now routed via the Spine.\n\nFlow (configurable by flags):\n  1) Build PatchLoopConfig-style payload from CLI\n  2) Ask Spine to run the LLM pipeline (capability: llm.engine.run.v1) [--only-apply to skip]\n  3) Gather *.patch files from the **run directory only** (no global drop-zones)\n  4) Ask Spine to apply patches (capability: patch.apply_files.v1)\n\nNo DB schema changes. No Git usage for patch application.\nAll patch/mirror/workspace artifacts live **inside the run directory**.\n\"\"\"\n\nimport argparse\nimport importlib.util\nimport os\nimport re\nimport sys\nfrom pathlib import Path\nfrom typing import Any, Dict, List, Optional\n\n# --- Spine bus -----------------------------------------------------------------\n```\n--\nid: 1794\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n# File: v2/patches/executor/run_patch_loop.py\n#!/usr/bin/env python3\nfrom __future__ import annotations\n\n\"\"\"\nCLI entrypoint for the patch loop (non-IDE) — now routed via the Spine.\n\nDifferences vs local:\n- Quieter by default (use --verbose to increase logs)\n- Different default out_base (output/patches_cli)\n- Does not apply patches; it only runs the LLM pipeline and prints the run dir\n\"\"\"\n\nimport argparse\nimport importlib.util\nimport os\nimport re\nimport sys\nfrom pathlib import Path\nfrom typing import Any, Dict, Optional\n\n# --- Spine bus -----------------------------------------------------------------\nfrom v2.backend.core.spine import Spine, to_dict\n\n# --- Existing types (for payload shaping) --------------------------------------\nfrom v2.backend.core.configuration.config import PatchLoopConfig\n```\n--\nid: 1793\nmode: create\nsignature: module\ndescription: Map human-friendly profile to AskSpec and apply overrides.\ncontext_code:\n```python\n# File: v2/patches/executor/run_patch_loop.py\n#!/usr/bin/env python3\nfrom __future__ import annotations\n\n\"\"\"\nCLI entrypoint for the patch loop (non-IDE) — now routed via the Spine.\n\nDifferences vs local:\n- Quieter by default (use --verbose to increase logs)\n- Different default out_base (output/patches_cli)\n- Does not apply patches; it only runs the LLM pipeline and prints the run dir\n\"\"\"\n\nimport argparse\nimport importlib.util\nimport os\nimport re\nimport sys\nfrom pathlib import Path\nfrom typing import Any, Dict, Optional\n\n# --- Spine bus -----------------------------------------------------------------\nfrom v2.backend.core.spine import Spine, to_dict\n\n# --- Existing types (for payload shaping) --------------------------------------\nfrom v2.backend.core.configuration.config import PatchLoopConfig\n```\n--\nid: 1792\nmode: create\nsignature: module\ndescription: Resolve OpenAI API key using all supported sources.\ncontext_code:\n```python\n# File: v2/patches/executor/run_patch_loop.py\n#!/usr/bin/env python3\nfrom __future__ import annotations\n\n\"\"\"\nCLI entrypoint for the patch loop (non-IDE) — now routed via the Spine.\n\nDifferences vs local:\n- Quieter by default (use --verbose to increase logs)\n- Different default out_base (output/patches_cli)\n- Does not apply patches; it only runs the LLM pipeline and prints the run dir\n\"\"\"\n\nimport argparse\nimport importlib.util\nimport os\nimport re\nimport sys\nfrom pathlib import Path\nfrom typing import Any, Dict, Optional\n\n# --- Spine bus -----------------------------------------------------------------\nfrom v2.backend.core.spine import Spine, to_dict\n\n# --- Existing types (for payload shaping) --------------------------------------\nfrom v2.backend.core.configuration.config import PatchLoopConfig\n```\n--\nid: 1791\nmode: create\nsignature: module\ndescription: Read secrets from `secrets.yaml` using PyYAML if installed, otherwise a simple parser.\ncontext_code:\n```python\n# File: v2/patches/executor/run_patch_loop.py\n#!/usr/bin/env python3\nfrom __future__ import annotations\n\n\"\"\"\nCLI entrypoint for the patch loop (non-IDE) — now routed via the Spine.\n\nDifferences vs local:\n- Quieter by default (use --verbose to increase logs)\n- Different default out_base (output/patches_cli)\n- Does not apply patches; it only runs the LLM pipeline and prints the run dir\n\"\"\"\n\nimport argparse\nimport importlib.util\nimport os\nimport re\nimport sys\nfrom pathlib import Path\nfrom typing import Any, Dict, Optional\n\n# --- Spine bus -----------------------------------------------------------------\nfrom v2.backend.core.spine import Spine, to_dict\n\n# --- Existing types (for payload shaping) --------------------------------------\nfrom v2.backend.core.configuration.config import PatchLoopConfig\n```\n--\nid: 1790\nmode: create\nsignature: module\ndescription: Import and use the secrets management module through common entrypoints.\ncontext_code:\n```python\n# File: v2/patches/executor/run_patch_loop.py\n#!/usr/bin/env python3\nfrom __future__ import annotations\n\n\"\"\"\nCLI entrypoint for the patch loop (non-IDE) — now routed via the Spine.\n\nDifferences vs local:\n- Quieter by default (use --verbose to increase logs)\n- Different default out_base (output/patches_cli)\n- Does not apply patches; it only runs the LLM pipeline and prints the run dir\n\"\"\"\n\nimport argparse\nimport importlib.util\nimport os\nimport re\nimport sys\nfrom pathlib import Path\nfrom typing import Any, Dict, Optional\n\n# --- Spine bus -----------------------------------------------------------------\nfrom v2.backend.core.spine import Spine, to_dict\n\n# --- Existing types (for payload shaping) --------------------------------------\nfrom v2.backend.core.configuration.config import PatchLoopConfig\n```\n--\nid: 1789\nmode: create\nsignature: module\ndescription: Extracts an OpenAI API key from a secrets dict with various shapes.\ncontext_code:\n```python\n# File: v2/patches/executor/run_patch_loop.py\n#!/usr/bin/env python3\nfrom __future__ import annotations\n\n\"\"\"\nCLI entrypoint for the patch loop (non-IDE) — now routed via the Spine.\n\nDifferences vs local:\n- Quieter by default (use --verbose to increase logs)\n- Different default out_base (output/patches_cli)\n- Does not apply patches; it only runs the LLM pipeline and prints the run dir\n\"\"\"\n\nimport argparse\nimport importlib.util\nimport os\nimport re\nimport sys\nfrom pathlib import Path\nfrom typing import Any, Dict, Optional\n\n# --- Spine bus -----------------------------------------------------------------\nfrom v2.backend.core.spine import Spine, to_dict\n\n# --- Existing types (for payload shaping) --------------------------------------\nfrom v2.backend.core.configuration.config import PatchLoopConfig\n```\n--\nid: 1788\nmode: create\nsignature: module\ndescription: Derive a default project root for CLI runs.\ncontext_code:\n```python\n# File: v2/patches/executor/run_patch_loop.py\n#!/usr/bin/env python3\nfrom __future__ import annotations\n\n\"\"\"\nCLI entrypoint for the patch loop (non-IDE) — now routed via the Spine.\n\nDifferences vs local:\n- Quieter by default (use --verbose to increase logs)\n- Different default out_base (output/patches_cli)\n- Does not apply patches; it only runs the LLM pipeline and prints the run dir\n\"\"\"\n\nimport argparse\nimport importlib.util\nimport os\nimport re\nimport sys\nfrom pathlib import Path\nfrom typing import Any, Dict, Optional\n\n# --- Spine bus -----------------------------------------------------------------\nfrom v2.backend.core.spine import Spine, to_dict\n\n# --- Existing types (for payload shaping) --------------------------------------\nfrom v2.backend.core.configuration.config import PatchLoopConfig\n```\n--\nid: 1787\nmode: create\nsignature: module\ndescription: Walk up from 'start' to filesystem root and return first dir containing 'databases/bot_dev.db', or CWD if none found.\ncontext_code:\n```python\n# File: v2/patches/executor/run_patch_loop.py\n#!/usr/bin/env python3\nfrom __future__ import annotations\n\n\"\"\"\nCLI entrypoint for the patch loop (non-IDE) — now routed via the Spine.\n\nDifferences vs local:\n- Quieter by default (use --verbose to increase logs)\n- Different default out_base (output/patches_cli)\n- Does not apply patches; it only runs the LLM pipeline and prints the run dir\n\"\"\"\n\nimport argparse\nimport importlib.util\nimport os\nimport re\nimport sys\nfrom pathlib import Path\nfrom typing import Any, Dict, Optional\n\n# --- Spine bus -----------------------------------------------------------------\nfrom v2.backend.core.spine import Spine, to_dict\n\n# --- Existing types (for payload shaping) --------------------------------------\nfrom v2.backend.core.configuration.config import PatchLoopConfig\n```\n--\nid: 1786\nmode: rewrite\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n\"\"\"Core primitives: errors, types, budget, logs.\"\"\"\n```\n--\nid: 1785\nmode: create\nsignature: module\ndescription: Update/create module or function docstring at target_lineno, preserving indentation and ensuring no backslash after opening quotes.\ncontext_code:\n```python\nfrom __future__ import annotations\n\nimport ast\nimport io\nimport re\nfrom dataclasses import dataclass\nfrom typing import Optional, Tuple\n\n\n_DOCSTRING_RX = re.compile(r'^[ \\t]*[ruRUbB]*(\"\"\"|\\'\\'\\')')\n_ENCODING_RX = re.compile(r'^[ \\t]*#.*coding[:=][ \\t]*([-\\w.]+)')\n\n\ndef _split_lines(src: str) -> list[str]:\n    # Keep original newlines so CRLF survives via FileOps (which mirrors endings)\n    return src.splitlines(keepends=True)\n\n\ndef _indent_of(line: str) -> str:\n    return line[: len(line) - len(line.lstrip(\" \\t\"))]\n\n\ndef _guess_body_indent(lines: list[str], def_lineno1: int, fallback: str) -> str:\n    \"\"\"\n    Guess inner-body indentation for a function/class by scanning the next\n    non-empty, non-comment line after the 'def/class' header.\n```\n--\nid: 1784\nmode: create\nsignature: module\ndescription: Insert new block after line index.\ncontext_code:\n```python\nfrom __future__ import annotations\n\nimport ast\nimport io\nimport re\nfrom dataclasses import dataclass\nfrom typing import Optional, Tuple\n\n\n_DOCSTRING_RX = re.compile(r'^[ \\t]*[ruRUbB]*(\"\"\"|\\'\\'\\')')\n_ENCODING_RX = re.compile(r'^[ \\t]*#.*coding[:=][ \\t]*([-\\w.]+)')\n\n\ndef _split_lines(src: str) -> list[str]:\n    # Keep original newlines so CRLF survives via FileOps (which mirrors endings)\n    return src.splitlines(keepends=True)\n\n\ndef _indent_of(line: str) -> str:\n    return line[: len(line) - len(line.lstrip(\" \\t\"))]\n\n\ndef _guess_body_indent(lines: list[str], def_lineno1: int, fallback: str) -> str:\n    \"\"\"\n    Guess inner-body indentation for a function/class by scanning the next\n    non-empty, non-comment line after the 'def/class' header.\n```\n--\nid: 1783\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\nfrom __future__ import annotations\n\nimport ast\nimport io\nimport re\nfrom dataclasses import dataclass\nfrom typing import Optional, Tuple\n\n\n_DOCSTRING_RX = re.compile(r'^[ \\t]*[ruRUbB]*(\"\"\"|\\'\\'\\')')\n_ENCODING_RX = re.compile(r'^[ \\t]*#.*coding[:=][ \\t]*([-\\w.]+)')\n\n\ndef _split_lines(src: str) -> list[str]:\n    # Keep original newlines so CRLF survives via FileOps (which mirrors endings)\n    return src.splitlines(keepends=True)\n\n\ndef _indent_of(line: str) -> str:\n    return line[: len(line) - len(line.lstrip(\" \\t\"))]\n\n\ndef _guess_body_indent(lines: list[str], def_lineno1: int, fallback: str) -> str:\n    \"\"\"\n    Guess inner-body indentation for a function/class by scanning the next\n    non-empty, non-comment line after the 'def/class' header.\n```\n--\nid: 1782\nmode: create\nsignature: module\ndescription: Insert module docstring at the top of the Python file.\ncontext_code:\n```python\nfrom __future__ import annotations\n\nimport ast\nimport io\nimport re\nfrom dataclasses import dataclass\nfrom typing import Optional, Tuple\n\n\n_DOCSTRING_RX = re.compile(r'^[ \\t]*[ruRUbB]*(\"\"\"|\\'\\'\\')')\n_ENCODING_RX = re.compile(r'^[ \\t]*#.*coding[:=][ \\t]*([-\\w.]+)')\n\n\ndef _split_lines(src: str) -> list[str]:\n    # Keep original newlines so CRLF survives via FileOps (which mirrors endings)\n    return src.splitlines(keepends=True)\n\n\ndef _indent_of(line: str) -> str:\n    return line[: len(line) - len(line.lstrip(\" \\t\"))]\n\n\ndef _guess_body_indent(lines: list[str], def_lineno1: int, fallback: str) -> str:\n    \"\"\"\n    Guess inner-body indentation for a function/class by scanning the next\n    non-empty, non-comment line after the 'def/class' header.\n```\n--\nid: 1781\nmode: create\nsignature: module\ndescription: Returns docstring indices for existing docstring.\ncontext_code:\n```python\nfrom __future__ import annotations\n\nimport ast\nimport io\nimport re\nfrom dataclasses import dataclass\nfrom typing import Optional, Tuple\n\n\n_DOCSTRING_RX = re.compile(r'^[ \\t]*[ruRUbB]*(\"\"\"|\\'\\'\\')')\n_ENCODING_RX = re.compile(r'^[ \\t]*#.*coding[:=][ \\t]*([-\\w.]+)')\n\n\ndef _split_lines(src: str) -> list[str]:\n    # Keep original newlines so CRLF survives via FileOps (which mirrors endings)\n    return src.splitlines(keepends=True)\n\n\ndef _indent_of(line: str) -> str:\n    return line[: len(line) - len(line.lstrip(\" \\t\"))]\n\n\ndef _guess_body_indent(lines: list[str], def_lineno1: int, fallback: str) -> str:\n    \"\"\"\n    Guess inner-body indentation for a function/class by scanning the next\n    non-empty, non-comment line after the 'def/class' header.\n```\n--\nid: 1780\nmode: create\nsignature: module\ndescription: Render a PEP-257 style docstring with no backslash after opening quotes and a blank line after the summary. The `content` is the model output without triple quotes.\ncontext_code:\n```python\nfrom __future__ import annotations\n\nimport ast\nimport io\nimport re\nfrom dataclasses import dataclass\nfrom typing import Optional, Tuple\n\n\n_DOCSTRING_RX = re.compile(r'^[ \\t]*[ruRUbB]*(\"\"\"|\\'\\'\\')')\n_ENCODING_RX = re.compile(r'^[ \\t]*#.*coding[:=][ \\t]*([-\\w.]+)')\n\n\ndef _split_lines(src: str) -> list[str]:\n    # Keep original newlines so CRLF survives via FileOps (which mirrors endings)\n    return src.splitlines(keepends=True)\n\n\ndef _indent_of(line: str) -> str:\n    return line[: len(line) - len(line.lstrip(\" \\t\"))]\n\n\ndef _guess_body_indent(lines: list[str], def_lineno1: int, fallback: str) -> str:\n    \"\"\"\n    Guess inner-body indentation for a function/class by scanning the next\n    non-empty, non-comment line after the 'def/class' header.\n```\n--\nid: 1779\nmode: create\nsignature: module\ndescription: Scan next non-empty, non-comment line after 'def/class' header to guess inner-body indentation.\ncontext_code:\n```python\nfrom __future__ import annotations\n\nimport ast\nimport io\nimport re\nfrom dataclasses import dataclass\nfrom typing import Optional, Tuple\n\n\n_DOCSTRING_RX = re.compile(r'^[ \\t]*[ruRUbB]*(\"\"\"|\\'\\'\\')')\n_ENCODING_RX = re.compile(r'^[ \\t]*#.*coding[:=][ \\t]*([-\\w.]+)')\n\n\ndef _split_lines(src: str) -> list[str]:\n    # Keep original newlines so CRLF survives via FileOps (which mirrors endings)\n    return src.splitlines(keepends=True)\n\n\ndef _indent_of(line: str) -> str:\n    return line[: len(line) - len(line.lstrip(\" \\t\"))]\n\n\ndef _guess_body_indent(lines: list[str], def_lineno1: int, fallback: str) -> str:\n    \"\"\"\n    Guess inner-body indentation for a function/class by scanning the next\n    non-empty, non-comment line after the 'def/class' header.\n```\n--\nid: 1778\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\nfrom __future__ import annotations\n\nimport ast\nimport io\nimport re\nfrom dataclasses import dataclass\nfrom typing import Optional, Tuple\n\n\n_DOCSTRING_RX = re.compile(r'^[ \\t]*[ruRUbB]*(\"\"\"|\\'\\'\\')')\n_ENCODING_RX = re.compile(r'^[ \\t]*#.*coding[:=][ \\t]*([-\\w.]+)')\n\n\ndef _split_lines(src: str) -> list[str]:\n    # Keep original newlines so CRLF survives via FileOps (which mirrors endings)\n    return src.splitlines(keepends=True)\n\n\ndef _indent_of(line: str) -> str:\n    return line[: len(line) - len(line.lstrip(\" \\t\"))]\n\n\ndef _guess_body_indent(lines: list[str], def_lineno1: int, fallback: str) -> str:\n    \"\"\"\n    Guess inner-body indentation for a function/class by scanning the next\n    non-empty, non-comment line after the 'def/class' header.\n```\n--\nid: 1777\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\nfrom __future__ import annotations\n\nimport ast\nimport io\nimport re\nfrom dataclasses import dataclass\nfrom typing import Optional, Tuple\n\n\n_DOCSTRING_RX = re.compile(r'^[ \\t]*[ruRUbB]*(\"\"\"|\\'\\'\\')')\n_ENCODING_RX = re.compile(r'^[ \\t]*#.*coding[:=][ \\t]*([-\\w.]+)')\n\n\ndef _split_lines(src: str) -> list[str]:\n    # Keep original newlines so CRLF survives via FileOps (which mirrors endings)\n    return src.splitlines(keepends=True)\n\n\ndef _indent_of(line: str) -> str:\n    return line[: len(line) - len(line.lstrip(\" \\t\"))]\n\n\ndef _guess_body_indent(lines: list[str], def_lineno1: int, fallback: str) -> str:\n    \"\"\"\n    Guess inner-body indentation for a function/class by scanning the next\n    non-empty, non-comment line after the 'def/class' header.\n```\n--\nid: 1776\nmode: create\nsignature: module\ndescription: Write updated file to /sandbox_applied/ under the same run root.\ncontext_code:\n```python\n# File: patches/core/patch_ops.py\nfrom __future__ import annotations\n\nimport difflib\nimport hashlib\nfrom dataclasses import dataclass\nfrom pathlib import Path\nfrom typing import Optional\n\nfrom v2.backend.core.utils.io.file_ops import FileOps\n\n\n@dataclass\nclass PatchOps:\n    file_ops: FileOps\n\n    def _patch_path(self, root: Path, base_name: str, suffix: Optional[str] = None) -> Path:\n        \"\"\"\n        Build a deterministic patch path at the **run root** (no /patches subdir).\n        If suffix is provided (e.g., '__'), it's appended before '.patch'.\n        \"\"\"\n        root.mkdir(parents=True, exist_ok=True)\n        name = f\"{base_name}{suffix or ''}.patch\"\n        return root / name\n\n    @staticmethod\n```\n--\nid: 1775\nmode: create\nsignature: module\ndescription: Write a unified diff patch file.\ncontext_code:\n```python\n# File: patches/core/patch_ops.py\nfrom __future__ import annotations\n\nimport difflib\nimport hashlib\nfrom dataclasses import dataclass\nfrom pathlib import Path\nfrom typing import Optional\n\nfrom v2.backend.core.utils.io.file_ops import FileOps\n\n\n@dataclass\nclass PatchOps:\n    file_ops: FileOps\n\n    def _patch_path(self, root: Path, base_name: str, suffix: Optional[str] = None) -> Path:\n        \"\"\"\n        Build a deterministic patch path at the **run root** (no /patches subdir).\n        If suffix is provided (e.g., '__'), it's appended before '.patch'.\n        \"\"\"\n        root.mkdir(parents=True, exist_ok=True)\n        name = f\"{base_name}{suffix or ''}.patch\"\n        return root / name\n\n    @staticmethod\n```\n--\nid: 1774\nmode: create\nsignature: module\ndescription: This function creates a unified diff with minimal context.\ncontext_code:\n```python\n# File: patches/core/patch_ops.py\nfrom __future__ import annotations\n\nimport difflib\nimport hashlib\nfrom dataclasses import dataclass\nfrom pathlib import Path\nfrom typing import Optional\n\nfrom v2.backend.core.utils.io.file_ops import FileOps\n\n\n@dataclass\nclass PatchOps:\n    file_ops: FileOps\n\n    def _patch_path(self, root: Path, base_name: str, suffix: Optional[str] = None) -> Path:\n        \"\"\"\n        Build a deterministic patch path at the **run root** (no /patches subdir).\n        If suffix is provided (e.g., '__'), it's appended before '.patch'.\n        \"\"\"\n        root.mkdir(parents=True, exist_ok=True)\n        name = f\"{base_name}{suffix or ''}.patch\"\n        return root / name\n\n    @staticmethod\n```\n--\nid: 1773\nmode: create\nsignature: module\ndescription: Build deterministic patch path at run root with optional suffix.\ncontext_code:\n```python\n# File: patches/core/patch_ops.py\nfrom __future__ import annotations\n\nimport difflib\nimport hashlib\nfrom dataclasses import dataclass\nfrom pathlib import Path\nfrom typing import Optional\n\nfrom v2.backend.core.utils.io.file_ops import FileOps\n\n\n@dataclass\nclass PatchOps:\n    file_ops: FileOps\n\n    def _patch_path(self, root: Path, base_name: str, suffix: Optional[str] = None) -> Path:\n        \"\"\"\n        Build a deterministic patch path at the **run root** (no /patches subdir).\n        If suffix is provided (e.g., '__'), it's appended before '.patch'.\n        \"\"\"\n        root.mkdir(parents=True, exist_ok=True)\n        name = f\"{base_name}{suffix or ''}.patch\"\n        return root / name\n\n    @staticmethod\n```\n--\nid: 1772\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n# File: patches/core/patch_ops.py\nfrom __future__ import annotations\n\nimport difflib\nimport hashlib\nfrom dataclasses import dataclass\nfrom pathlib import Path\nfrom typing import Optional\n\nfrom v2.backend.core.utils.io.file_ops import FileOps\n\n\n@dataclass\nclass PatchOps:\n    file_ops: FileOps\n\n    def _patch_path(self, root: Path, base_name: str, suffix: Optional[str] = None) -> Path:\n        \"\"\"\n        Build a deterministic patch path at the **run root** (no /patches subdir).\n        If suffix is provided (e.g., '__'), it's appended before '.patch'.\n        \"\"\"\n        root.mkdir(parents=True, exist_ok=True)\n        name = f\"{base_name}{suffix or ''}.patch\"\n        return root / name\n\n    @staticmethod\n```\n--\nid: 1771\nmode: rewrite\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n\"\"\"Core primitives: errors, types, budget, logs.\"\"\"\n```\n--\nid: 1770\nmode: rewrite\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n\"\"\"\nIntrospection Index Models\nCaptures structural code symbols (functions, classes, routes) and their relationships.\n\nSchema: introspection_index\n\"\"\"\n\nfrom typing import Optional\nfrom pydantic import BaseModel, Field\nfrom datetime import datetime\nfrom sqlalchemy import (\n        Column, Integer, String, Text, TIMESTAMP\n    )\nfrom sqlalchemy.sql import func\nfrom sqlalchemy.ext.declarative import declarative_base\nBase = declarative_base()\nSQLALCHEMY_AVAILABLE = True\n\n# ---- SQLAlchemy ORM Model ----\n\n\n\nif SQLALCHEMY_AVAILABLE:\n    class IntrospectionIndex(Base):\n        __tablename__ = \"introspection_index\"\n\n```\n--\nid: 1769\nmode: rewrite\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n\"\"\"\nIntrospection Index Models\nCaptures structural code symbols (functions, classes, routes) and their relationships.\n\nSchema: introspection_index\n\"\"\"\n\nfrom typing import Optional\nfrom pydantic import BaseModel, Field\nfrom datetime import datetime\nfrom sqlalchemy import (\n        Column, Integer, String, Text, TIMESTAMP\n    )\nfrom sqlalchemy.sql import func\nfrom sqlalchemy.ext.declarative import declarative_base\nBase = declarative_base()\nSQLALCHEMY_AVAILABLE = True\n\n# ---- SQLAlchemy ORM Model ----\n\n\n\nif SQLALCHEMY_AVAILABLE:\n    class IntrospectionIndex(Base):\n        __tablename__ = \"introspection_index\"\n\n```\n--\nid: 1768\nmode: rewrite\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n\"\"\"\nIntrospection Index Models\nCaptures structural code symbols (functions, classes, routes) and their relationships.\n\nSchema: introspection_index\n\"\"\"\n\nfrom typing import Optional\nfrom pydantic import BaseModel, Field\nfrom datetime import datetime\nfrom sqlalchemy import (\n        Column, Integer, String, Text, TIMESTAMP\n    )\nfrom sqlalchemy.sql import func\nfrom sqlalchemy.ext.declarative import declarative_base\nBase = declarative_base()\nSQLALCHEMY_AVAILABLE = True\n\n# ---- SQLAlchemy ORM Model ----\n\n\n\nif SQLALCHEMY_AVAILABLE:\n    class IntrospectionIndex(Base):\n        __tablename__ = \"introspection_index\"\n\n```\n--\nid: 1767\nmode: rewrite\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n\"\"\"\nIntrospection Index Models\nCaptures structural code symbols (functions, classes, routes) and their relationships.\n\nSchema: introspection_index\n\"\"\"\n\nfrom typing import Optional\nfrom pydantic import BaseModel, Field\nfrom datetime import datetime\nfrom sqlalchemy import (\n        Column, Integer, String, Text, TIMESTAMP\n    )\nfrom sqlalchemy.sql import func\nfrom sqlalchemy.ext.declarative import declarative_base\nBase = declarative_base()\nSQLALCHEMY_AVAILABLE = True\n\n# ---- SQLAlchemy ORM Model ----\n\n\n\nif SQLALCHEMY_AVAILABLE:\n    class IntrospectionIndex(Base):\n        __tablename__ = \"introspection_index\"\n\n```\n--\nid: 1766\nmode: rewrite\nsignature: module\ndescription: Captures code symbols and relationships using the \"introspection_index\" schema.\ncontext_code:\n```python\n\"\"\"\nIntrospection Index Models\nCaptures structural code symbols (functions, classes, routes) and their relationships.\n\nSchema: introspection_index\n\"\"\"\n\nfrom typing import Optional\nfrom pydantic import BaseModel, Field\nfrom datetime import datetime\nfrom sqlalchemy import (\n        Column, Integer, String, Text, TIMESTAMP\n    )\nfrom sqlalchemy.sql import func\nfrom sqlalchemy.ext.declarative import declarative_base\nBase = declarative_base()\nSQLALCHEMY_AVAILABLE = True\n\n# ---- SQLAlchemy ORM Model ----\n\n\n\nif SQLALCHEMY_AVAILABLE:\n    class IntrospectionIndex(Base):\n        __tablename__ = \"introspection_index\"\n\n```\n--\nid: 1765\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n# File: v2/models/introspection_index.py\nfrom __future__ import annotations\n\nfrom datetime import datetime\nfrom typing import Any, Dict, Literal, Optional\n\nimport json\nfrom sqlalchemy import (\n    TIMESTAMP,\n    Integer,\n    String,\n    Text,\n    func,\n    Index,\n    UniqueConstraint,\n)\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column\n\n# ----------------------------- SQLAlchemy Base --------------------------------\n\nclass Base(DeclarativeBase):\n    \"\"\"Local declarative base for ORM models in this bundle.\"\"\"\n    pass\n\n\n# ----------------------------- Type Aliases -----------------------------------\n```\n--\nid: 1764\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n# File: v2/models/introspection_index.py\nfrom __future__ import annotations\n\nfrom datetime import datetime\nfrom typing import Any, Dict, Literal, Optional\n\nimport json\nfrom sqlalchemy import (\n    TIMESTAMP,\n    Integer,\n    String,\n    Text,\n    func,\n    Index,\n    UniqueConstraint,\n)\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column\n\n# ----------------------------- SQLAlchemy Base --------------------------------\n\nclass Base(DeclarativeBase):\n    \"\"\"Local declarative base for ORM models in this bundle.\"\"\"\n    pass\n\n\n# ----------------------------- Type Aliases -----------------------------------\n```\n--\nid: 1763\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n# File: v2/models/introspection_index.py\nfrom __future__ import annotations\n\nfrom datetime import datetime\nfrom typing import Any, Dict, Literal, Optional\n\nimport json\nfrom sqlalchemy import (\n    TIMESTAMP,\n    Integer,\n    String,\n    Text,\n    func,\n    Index,\n    UniqueConstraint,\n)\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column\n\n# ----------------------------- SQLAlchemy Base --------------------------------\n\nclass Base(DeclarativeBase):\n    \"\"\"Local declarative base for ORM models in this bundle.\"\"\"\n    pass\n\n\n# ----------------------------- Type Aliases -----------------------------------\n```\n--\nid: 1762\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n# File: v2/models/introspection_index.py\nfrom __future__ import annotations\n\nfrom datetime import datetime\nfrom typing import Any, Dict, Literal, Optional\n\nimport json\nfrom sqlalchemy import (\n    TIMESTAMP,\n    Integer,\n    String,\n    Text,\n    func,\n    Index,\n    UniqueConstraint,\n)\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column\n\n# ----------------------------- SQLAlchemy Base --------------------------------\n\nclass Base(DeclarativeBase):\n    \"\"\"Local declarative base for ORM models in this bundle.\"\"\"\n    pass\n\n\n# ----------------------------- Type Aliases -----------------------------------\n```\n--\nid: 1761\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n# File: v2/models/introspection_index.py\nfrom __future__ import annotations\n\nfrom datetime import datetime\nfrom typing import Any, Dict, Literal, Optional\n\nimport json\nfrom sqlalchemy import (\n    TIMESTAMP,\n    Integer,\n    String,\n    Text,\n    func,\n    Index,\n    UniqueConstraint,\n)\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column\n\n# ----------------------------- SQLAlchemy Base --------------------------------\n\nclass Base(DeclarativeBase):\n    \"\"\"Local declarative base for ORM models in this bundle.\"\"\"\n    pass\n\n\n# ----------------------------- Type Aliases -----------------------------------\n```\n--\nid: 1760\nmode: create\nsignature: module\ndescription: Stores minimal identity, location, and metadata of discovered code symbols during introspection scans.\ncontext_code:\n```python\n# File: v2/models/introspection_index.py\nfrom __future__ import annotations\n\nfrom datetime import datetime\nfrom typing import Any, Dict, Literal, Optional\n\nimport json\nfrom sqlalchemy import (\n    TIMESTAMP,\n    Integer,\n    String,\n    Text,\n    func,\n    Index,\n    UniqueConstraint,\n)\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column\n\n# ----------------------------- SQLAlchemy Base --------------------------------\n\nclass Base(DeclarativeBase):\n    \"\"\"Local declarative base for ORM models in this bundle.\"\"\"\n    pass\n\n\n# ----------------------------- Type Aliases -----------------------------------\n```\n--\nid: 1759\nmode: create\nsignature: module\ndescription: Stores dense vector embeddings for rows in introspection_index as BLOB.\ncontext_code:\n```python\nfrom __future__ import annotations\nfrom typing import Optional, Literal\nfrom datetime import datetime\n\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column\nfrom sqlalchemy import Integer, Text, String, BLOB, TIMESTAMP, func, Index, UniqueConstraint, ForeignKey\n\n# Use the same DeclarativeBase pattern as other models; if you already\n# have a shared Base, import and reuse it instead of redefining.\nclass Base(DeclarativeBase):\n    pass\n\nEmbeddingFormat = Literal[\"array\", \"blob\"]  # how you serialize client-side (informational)\n\nclass IntrospectionEmbedding(Base):\n    \"\"\"\n    Stores dense vector embeddings for rows in introspection_index.\n    One row per (item_id, model). Embedding stored as BLOB (e.g., float32 array).\n    \"\"\"\n    __tablename__ = \"introspection_index_embeddings\"\n\n    id: Mapped[int] = mapped_column(Integer, primary_key=True)\n    item_id: Mapped[int] = mapped_column(\n        Integer,\n        ForeignKey(\"introspection_index.id\", ondelete=\"CASCADE\"),\n        nullable=False,\n```\n--\nid: 1758\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\nfrom __future__ import annotations\nfrom typing import Optional, Literal\nfrom datetime import datetime\n\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column\nfrom sqlalchemy import Integer, Text, String, BLOB, TIMESTAMP, func, Index, UniqueConstraint, ForeignKey\n\n# Use the same DeclarativeBase pattern as other models; if you already\n# have a shared Base, import and reuse it instead of redefining.\nclass Base(DeclarativeBase):\n    pass\n\nEmbeddingFormat = Literal[\"array\", \"blob\"]  # how you serialize client-side (informational)\n\nclass IntrospectionEmbedding(Base):\n    \"\"\"\n    Stores dense vector embeddings for rows in introspection_index.\n    One row per (item_id, model). Embedding stored as BLOB (e.g., float32 array).\n    \"\"\"\n    __tablename__ = \"introspection_index_embeddings\"\n\n    id: Mapped[int] = mapped_column(Integer, primary_key=True)\n    item_id: Mapped[int] = mapped_column(\n        Integer,\n        ForeignKey(\"introspection_index.id\", ondelete=\"CASCADE\"),\n        nullable=False,\n```\n--\nid: 1757\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n# File: v2/models/agent_insights.py\nfrom __future__ import annotations\n\nfrom datetime import datetime\nfrom typing import Any, Dict, Optional, Literal\n\nimport json\nfrom sqlalchemy import (\n    TIMESTAMP,\n    Integer,\n    String,\n    Text,\n    Float,\n    Boolean,\n    func,\n    Index,\n    UniqueConstraint,\n)\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column\n\n# ----------------------------- SQLAlchemy Base --------------------------------\n\nclass Base(DeclarativeBase):\n    \"\"\"Local declarative base for ORM models in this bundle.\"\"\"\n    pass\n\n```\n--\nid: 1756\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n# File: v2/models/agent_insights.py\nfrom __future__ import annotations\n\nfrom datetime import datetime\nfrom typing import Any, Dict, Optional, Literal\n\nimport json\nfrom sqlalchemy import (\n    TIMESTAMP,\n    Integer,\n    String,\n    Text,\n    Float,\n    Boolean,\n    func,\n    Index,\n    UniqueConstraint,\n)\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column\n\n# ----------------------------- SQLAlchemy Base --------------------------------\n\nclass Base(DeclarativeBase):\n    \"\"\"Local declarative base for ORM models in this bundle.\"\"\"\n    pass\n\n```\n--\nid: 1755\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n# File: v2/models/agent_insights.py\nfrom __future__ import annotations\n\nfrom datetime import datetime\nfrom typing import Any, Dict, Optional, Literal\n\nimport json\nfrom sqlalchemy import (\n    TIMESTAMP,\n    Integer,\n    String,\n    Text,\n    Float,\n    Boolean,\n    func,\n    Index,\n    UniqueConstraint,\n)\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column\n\n# ----------------------------- SQLAlchemy Base --------------------------------\n\nclass Base(DeclarativeBase):\n    \"\"\"Local declarative base for ORM models in this bundle.\"\"\"\n    pass\n\n```\n--\nid: 1754\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n# File: v2/models/agent_insights.py\nfrom __future__ import annotations\n\nfrom datetime import datetime\nfrom typing import Any, Dict, Optional, Literal\n\nimport json\nfrom sqlalchemy import (\n    TIMESTAMP,\n    Integer,\n    String,\n    Text,\n    Float,\n    Boolean,\n    func,\n    Index,\n    UniqueConstraint,\n)\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column\n\n# ----------------------------- SQLAlchemy Base --------------------------------\n\nclass Base(DeclarativeBase):\n    \"\"\"Local declarative base for ORM models in this bundle.\"\"\"\n    pass\n\n```\n--\nid: 1753\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n# File: v2/models/agent_insights.py\nfrom __future__ import annotations\n\nfrom datetime import datetime\nfrom typing import Any, Dict, Optional, Literal\n\nimport json\nfrom sqlalchemy import (\n    TIMESTAMP,\n    Integer,\n    String,\n    Text,\n    Float,\n    Boolean,\n    func,\n    Index,\n    UniqueConstraint,\n)\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column\n\n# ----------------------------- SQLAlchemy Base --------------------------------\n\nclass Base(DeclarativeBase):\n    \"\"\"Local declarative base for ORM models in this bundle.\"\"\"\n    pass\n\n```\n--\nid: 1752\nmode: create\nsignature: module\ndescription: Stores insights with typed content and metadata tied to an agent or run ID.\ncontext_code:\n```python\n# File: v2/models/agent_insights.py\nfrom __future__ import annotations\n\nfrom datetime import datetime\nfrom typing import Any, Dict, Optional, Literal\n\nimport json\nfrom sqlalchemy import (\n    TIMESTAMP,\n    Integer,\n    String,\n    Text,\n    Float,\n    Boolean,\n    func,\n    Index,\n    UniqueConstraint,\n)\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column\n\n# ----------------------------- SQLAlchemy Base --------------------------------\n\nclass Base(DeclarativeBase):\n    \"\"\"Local declarative base for ORM models in this bundle.\"\"\"\n    pass\n\n```\n--\nid: 1751\nmode: create\nsignature: module\ndescription: This is the local declarative base for ORM models in the current bundle.\ncontext_code:\n```python\n# File: v2/models/agent_insights.py\nfrom __future__ import annotations\n\nfrom datetime import datetime\nfrom typing import Any, Dict, Optional, Literal\n\nimport json\nfrom sqlalchemy import (\n    TIMESTAMP,\n    Integer,\n    String,\n    Text,\n    Float,\n    Boolean,\n    func,\n    Index,\n    UniqueConstraint,\n)\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column\n\n# ----------------------------- SQLAlchemy Base --------------------------------\n\nclass Base(DeclarativeBase):\n    \"\"\"Local declarative base for ORM models in this bundle.\"\"\"\n    pass\n\n```\n--\nid: 1750\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n# File: v2/cli/docstring.py\n#!/usr/bin/env python3\nfrom __future__ import annotations\n\nimport argparse\nimport os\nimport sys\nfrom pathlib import Path\nfrom typing import Optional, List, Dict, Any\n\n# --- Spine --------------------------------------------------------------------\nfrom v2.backend.core.spine import Spine, to_dict\n\n# --- Use the SAME DB path as the writer/session -------------------------------\nfrom v2.backend.core.db.access.db_init import DB_PATH  # single source of truth\n\n\n# ------------------------------------------------------------------------------\n# DB bootstrap stays identical to original\n# ------------------------------------------------------------------------------\n\ndef _init_db_at_writer_path(project_root: Path) -> None:\n    \"\"\"\n    Initialize the SQLite schema in the exact DB file that the ORM/writer uses.\n    We monkey-patch the constants inside init_sqlite_dev to avoid drift.\n    \"\"\"\n```\n--\nid: 1749\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n# File: v2/cli/docstring.py\n#!/usr/bin/env python3\nfrom __future__ import annotations\n\nimport argparse\nimport os\nimport sys\nfrom pathlib import Path\nfrom typing import Optional, List, Dict, Any\n\n# --- Spine --------------------------------------------------------------------\nfrom v2.backend.core.spine import Spine, to_dict\n\n# --- Use the SAME DB path as the writer/session -------------------------------\nfrom v2.backend.core.db.access.db_init import DB_PATH  # single source of truth\n\n\n# ------------------------------------------------------------------------------\n# DB bootstrap stays identical to original\n# ------------------------------------------------------------------------------\n\ndef _init_db_at_writer_path(project_root: Path) -> None:\n    \"\"\"\n    Initialize the SQLite schema in the exact DB file that the ORM/writer uses.\n    We monkey-patch the constants inside init_sqlite_dev to avoid drift.\n    \"\"\"\n```\n--\nid: 1748\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n# File: v2/cli/docstring.py\n#!/usr/bin/env python3\nfrom __future__ import annotations\n\nimport argparse\nimport os\nimport sys\nfrom pathlib import Path\nfrom typing import Optional, List, Dict, Any\n\n# --- Spine --------------------------------------------------------------------\nfrom v2.backend.core.spine import Spine, to_dict\n\n# --- Use the SAME DB path as the writer/session -------------------------------\nfrom v2.backend.core.db.access.db_init import DB_PATH  # single source of truth\n\n\n# ------------------------------------------------------------------------------\n# DB bootstrap stays identical to original\n# ------------------------------------------------------------------------------\n\ndef _init_db_at_writer_path(project_root: Path) -> None:\n    \"\"\"\n    Initialize the SQLite schema in the exact DB file that the ORM/writer uses.\n    We monkey-patch the constants inside init_sqlite_dev to avoid drift.\n    \"\"\"\n```\n--\nid: 1747\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n# File: v2/cli/docstring.py\n#!/usr/bin/env python3\nfrom __future__ import annotations\n\nimport argparse\nimport os\nimport sys\nfrom pathlib import Path\nfrom typing import Optional, List, Dict, Any\n\n# --- Spine --------------------------------------------------------------------\nfrom v2.backend.core.spine import Spine, to_dict\n\n# --- Use the SAME DB path as the writer/session -------------------------------\nfrom v2.backend.core.db.access.db_init import DB_PATH  # single source of truth\n\n\n# ------------------------------------------------------------------------------\n# DB bootstrap stays identical to original\n# ------------------------------------------------------------------------------\n\ndef _init_db_at_writer_path(project_root: Path) -> None:\n    \"\"\"\n    Initialize the SQLite schema in the exact DB file that the ORM/writer uses.\n    We monkey-patch the constants inside init_sqlite_dev to avoid drift.\n    \"\"\"\n```\n--\nid: 1746\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n# File: v2/cli/docstring.py\n#!/usr/bin/env python3\nfrom __future__ import annotations\n\nimport argparse\nimport os\nimport sys\nfrom pathlib import Path\nfrom typing import Optional, List, Dict, Any\n\n# --- Spine --------------------------------------------------------------------\nfrom v2.backend.core.spine import Spine, to_dict\n\n# --- Use the SAME DB path as the writer/session -------------------------------\nfrom v2.backend.core.db.access.db_init import DB_PATH  # single source of truth\n\n\n# ------------------------------------------------------------------------------\n# DB bootstrap stays identical to original\n# ------------------------------------------------------------------------------\n\ndef _init_db_at_writer_path(project_root: Path) -> None:\n    \"\"\"\n    Initialize the SQLite schema in the exact DB file that the ORM/writer uses.\n    We monkey-patch the constants inside init_sqlite_dev to avoid drift.\n    \"\"\"\n```\n--\nid: 1745\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n# File: v2/cli/docstring.py\n#!/usr/bin/env python3\nfrom __future__ import annotations\n\nimport argparse\nimport os\nimport sys\nfrom pathlib import Path\nfrom typing import Optional, List, Dict, Any\n\n# --- Spine --------------------------------------------------------------------\nfrom v2.backend.core.spine import Spine, to_dict\n\n# --- Use the SAME DB path as the writer/session -------------------------------\nfrom v2.backend.core.db.access.db_init import DB_PATH  # single source of truth\n\n\n# ------------------------------------------------------------------------------\n# DB bootstrap stays identical to original\n# ------------------------------------------------------------------------------\n\ndef _init_db_at_writer_path(project_root: Path) -> None:\n    \"\"\"\n    Initialize the SQLite schema in the exact DB file that the ORM/writer uses.\n    We monkey-patch the constants inside init_sqlite_dev to avoid drift.\n    \"\"\"\n```\n--\nid: 1744\nmode: create\nsignature: module\ndescription: Monkey-patch constants in `init_sqlite_dev` to avoid drift.\ncontext_code:\n```python\n# File: v2/cli/docstring.py\n#!/usr/bin/env python3\nfrom __future__ import annotations\n\nimport argparse\nimport os\nimport sys\nfrom pathlib import Path\nfrom typing import Optional, List, Dict, Any\n\n# --- Spine --------------------------------------------------------------------\nfrom v2.backend.core.spine import Spine, to_dict\n\n# --- Use the SAME DB path as the writer/session -------------------------------\nfrom v2.backend.core.db.access.db_init import DB_PATH  # single source of truth\n\n\n# ------------------------------------------------------------------------------\n# DB bootstrap stays identical to original\n# ------------------------------------------------------------------------------\n\ndef _init_db_at_writer_path(project_root: Path) -> None:\n    \"\"\"\n    Initialize the SQLite schema in the exact DB file that the ORM/writer uses.\n    We monkey-patch the constants inside init_sqlite_dev to avoid drift.\n    \"\"\"\n```\n--\nid: 1743\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\nimport os\n\n# 🔧 Set your target directory here\nTARGET_DIR = \"/v1/backend\\\\core\\\\\"\n#TARGET_DIR = \"G:\\\\My Drive\\\\ComfyUI\\\\packages\\\\comfyui-packages\\\\\"\n\ndef crawl_directory(path):\n    structure = {}\n    for root, dirs, files in os.walk(path):\n        #print(dirs, files)\n        # Build nested dictionary keys\n        rel_path = os.path.relpath(root, path)\n        parts = rel_path.split(os.sep) if rel_path != '.' else []\n        current = structure\n        if 'templates' not in parts:\n            for part in parts:\n                current = current.setdefault(part, {})\n        current[\"__files__\"] = files\n    return structure\n\ndef print_yaml_like(structure, indent=0):\n    for key, value in structure.items():\n        if key == \"__files__\":\n            for f in value:\n                print(\"  \" * indent + f\"- {f}\")\n                #pass\n```\n--\nid: 1742\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\nimport os\n\n# 🔧 Set your target directory here\nTARGET_DIR = \"/v1/backend\\\\core\\\\\"\n#TARGET_DIR = \"G:\\\\My Drive\\\\ComfyUI\\\\packages\\\\comfyui-packages\\\\\"\n\ndef crawl_directory(path):\n    structure = {}\n    for root, dirs, files in os.walk(path):\n        #print(dirs, files)\n        # Build nested dictionary keys\n        rel_path = os.path.relpath(root, path)\n        parts = rel_path.split(os.sep) if rel_path != '.' else []\n        current = structure\n        if 'templates' not in parts:\n            for part in parts:\n                current = current.setdefault(part, {})\n        current[\"__files__\"] = files\n    return structure\n\ndef print_yaml_like(structure, indent=0):\n    for key, value in structure.items():\n        if key == \"__files__\":\n            for f in value:\n                print(\"  \" * indent + f\"- {f}\")\n                #pass\n```\n--\nid: 1741\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\nimport os\nfrom collections import defaultdict\n\n# Define your root directory\nROOT_DIR = r\"/\"\n\n# Define script-like file extensions\nSCRIPT_EXTENSIONS = {'.py', '.sh', '.bat', '.ps1', '.js', '.ts', '.rb', '.pl', '.lua', '.php', '.r', '.java', '.cpp', '.c', '.cs'}\n\n# Initialize counters\noverall_incl_blank = 0\noverall_excl_blank = 0\nby_ext = defaultdict(lambda: {'incl': 0, 'excl': 0})\n\ndef is_script_file(filename):\n    return os.path.splitext(filename)[1].lower() in SCRIPT_EXTENSIONS\n\n# Walk through the directory\nfor root, _, files in os.walk(ROOT_DIR):\n    for file in files:\n        if is_script_file(file):\n            ext = os.path.splitext(file)[1].lower()\n            file_path = os.path.join(root, file)\n            try:\n                with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:\n                    lines = f.readlines()\n```\n--\nid: 1740\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n#!/usr/bin/env python3\n# code_indexer_standalone.py — lightweight multi-language code indexer (no CLI)\n# Scans PROJECT_ROOT for .py, .sql, .sh; builds a compact index and writes all chunks into ONE file.\n\nfrom __future__ import annotations\nimport ast\nimport json\nimport os\nimport sys\nimport re\nimport hashlib\nimport time\nimport platform\nfrom dataclasses import dataclass, asdict\nfrom pathlib import Path\nfrom typing import Dict, List, Optional, Tuple, Union, Iterable, Set\n\n# ======================= USER SETTINGS =======================\n\n# Scan this repo (escaped backslashes; not a raw string)\nPROJECT_ROOT = Path(\"/\\\\\")\n# Where to write outputs (single chunks file + full JSON)\nOUTPUT_DIR = Path(\"/tests_adhoc\")\n\n# Max characters per printed/saved chunk marker block\nMAX_CHARS = 18000\n```\n--\nid: 1739\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n#!/usr/bin/env python3\n# code_indexer_standalone.py — lightweight multi-language code indexer (no CLI)\n# Scans PROJECT_ROOT for .py, .sql, .sh; builds a compact index and writes all chunks into ONE file.\n\nfrom __future__ import annotations\nimport ast\nimport json\nimport os\nimport sys\nimport re\nimport hashlib\nimport time\nimport platform\nfrom dataclasses import dataclass, asdict\nfrom pathlib import Path\nfrom typing import Dict, List, Optional, Tuple, Union, Iterable, Set\n\n# ======================= USER SETTINGS =======================\n\n# Scan this repo (escaped backslashes; not a raw string)\nPROJECT_ROOT = Path(\"/\\\\\")\n# Where to write outputs (single chunks file + full JSON)\nOUTPUT_DIR = Path(\"/tests_adhoc\")\n\n# Max characters per printed/saved chunk marker block\nMAX_CHARS = 18000\n```\n--\nid: 1738\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n#!/usr/bin/env python3\n# code_indexer_standalone.py — lightweight multi-language code indexer (no CLI)\n# Scans PROJECT_ROOT for .py, .sql, .sh; builds a compact index and writes all chunks into ONE file.\n\nfrom __future__ import annotations\nimport ast\nimport json\nimport os\nimport sys\nimport re\nimport hashlib\nimport time\nimport platform\nfrom dataclasses import dataclass, asdict\nfrom pathlib import Path\nfrom typing import Dict, List, Optional, Tuple, Union, Iterable, Set\n\n# ======================= USER SETTINGS =======================\n\n# Scan this repo (escaped backslashes; not a raw string)\nPROJECT_ROOT = Path(\"/\\\\\")\n# Where to write outputs (single chunks file + full JSON)\nOUTPUT_DIR = Path(\"/tests_adhoc\")\n\n# Max characters per printed/saved chunk marker block\nMAX_CHARS = 18000\n```\n--\nid: 1737\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n#!/usr/bin/env python3\n# code_indexer_standalone.py — lightweight multi-language code indexer (no CLI)\n# Scans PROJECT_ROOT for .py, .sql, .sh; builds a compact index and writes all chunks into ONE file.\n\nfrom __future__ import annotations\nimport ast\nimport json\nimport os\nimport sys\nimport re\nimport hashlib\nimport time\nimport platform\nfrom dataclasses import dataclass, asdict\nfrom pathlib import Path\nfrom typing import Dict, List, Optional, Tuple, Union, Iterable, Set\n\n# ======================= USER SETTINGS =======================\n\n# Scan this repo (escaped backslashes; not a raw string)\nPROJECT_ROOT = Path(\"/\\\\\")\n# Where to write outputs (single chunks file + full JSON)\nOUTPUT_DIR = Path(\"/tests_adhoc\")\n\n# Max characters per printed/saved chunk marker block\nMAX_CHARS = 18000\n```\n--\nid: 1736\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n#!/usr/bin/env python3\n# code_indexer_standalone.py — lightweight multi-language code indexer (no CLI)\n# Scans PROJECT_ROOT for .py, .sql, .sh; builds a compact index and writes all chunks into ONE file.\n\nfrom __future__ import annotations\nimport ast\nimport json\nimport os\nimport sys\nimport re\nimport hashlib\nimport time\nimport platform\nfrom dataclasses import dataclass, asdict\nfrom pathlib import Path\nfrom typing import Dict, List, Optional, Tuple, Union, Iterable, Set\n\n# ======================= USER SETTINGS =======================\n\n# Scan this repo (escaped backslashes; not a raw string)\nPROJECT_ROOT = Path(\"/\\\\\")\n# Where to write outputs (single chunks file + full JSON)\nOUTPUT_DIR = Path(\"/tests_adhoc\")\n\n# Max characters per printed/saved chunk marker block\nMAX_CHARS = 18000\n```\n--\nid: 1735\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n#!/usr/bin/env python3\n# code_indexer_standalone.py — lightweight multi-language code indexer (no CLI)\n# Scans PROJECT_ROOT for .py, .sql, .sh; builds a compact index and writes all chunks into ONE file.\n\nfrom __future__ import annotations\nimport ast\nimport json\nimport os\nimport sys\nimport re\nimport hashlib\nimport time\nimport platform\nfrom dataclasses import dataclass, asdict\nfrom pathlib import Path\nfrom typing import Dict, List, Optional, Tuple, Union, Iterable, Set\n\n# ======================= USER SETTINGS =======================\n\n# Scan this repo (escaped backslashes; not a raw string)\nPROJECT_ROOT = Path(\"/\\\\\")\n# Where to write outputs (single chunks file + full JSON)\nOUTPUT_DIR = Path(\"/tests_adhoc\")\n\n# Max characters per printed/saved chunk marker block\nMAX_CHARS = 18000\n```\n--\nid: 1734\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n#!/usr/bin/env python3\n# code_indexer_standalone.py — lightweight multi-language code indexer (no CLI)\n# Scans PROJECT_ROOT for .py, .sql, .sh; builds a compact index and writes all chunks into ONE file.\n\nfrom __future__ import annotations\nimport ast\nimport json\nimport os\nimport sys\nimport re\nimport hashlib\nimport time\nimport platform\nfrom dataclasses import dataclass, asdict\nfrom pathlib import Path\nfrom typing import Dict, List, Optional, Tuple, Union, Iterable, Set\n\n# ======================= USER SETTINGS =======================\n\n# Scan this repo (escaped backslashes; not a raw string)\nPROJECT_ROOT = Path(\"/\\\\\")\n# Where to write outputs (single chunks file + full JSON)\nOUTPUT_DIR = Path(\"/tests_adhoc\")\n\n# Max characters per printed/saved chunk marker block\nMAX_CHARS = 18000\n```\n--\nid: 1733\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n#!/usr/bin/env python3\n# code_indexer_standalone.py — lightweight multi-language code indexer (no CLI)\n# Scans PROJECT_ROOT for .py, .sql, .sh; builds a compact index and writes all chunks into ONE file.\n\nfrom __future__ import annotations\nimport ast\nimport json\nimport os\nimport sys\nimport re\nimport hashlib\nimport time\nimport platform\nfrom dataclasses import dataclass, asdict\nfrom pathlib import Path\nfrom typing import Dict, List, Optional, Tuple, Union, Iterable, Set\n\n# ======================= USER SETTINGS =======================\n\n# Scan this repo (escaped backslashes; not a raw string)\nPROJECT_ROOT = Path(\"/\\\\\")\n# Where to write outputs (single chunks file + full JSON)\nOUTPUT_DIR = Path(\"/tests_adhoc\")\n\n# Max characters per printed/saved chunk marker block\nMAX_CHARS = 18000\n```\n--\nid: 1732\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n#!/usr/bin/env python3\n# code_indexer_standalone.py — lightweight multi-language code indexer (no CLI)\n# Scans PROJECT_ROOT for .py, .sql, .sh; builds a compact index and writes all chunks into ONE file.\n\nfrom __future__ import annotations\nimport ast\nimport json\nimport os\nimport sys\nimport re\nimport hashlib\nimport time\nimport platform\nfrom dataclasses import dataclass, asdict\nfrom pathlib import Path\nfrom typing import Dict, List, Optional, Tuple, Union, Iterable, Set\n\n# ======================= USER SETTINGS =======================\n\n# Scan this repo (escaped backslashes; not a raw string)\nPROJECT_ROOT = Path(\"/\\\\\")\n# Where to write outputs (single chunks file + full JSON)\nOUTPUT_DIR = Path(\"/tests_adhoc\")\n\n# Max characters per printed/saved chunk marker block\nMAX_CHARS = 18000\n```\n--\nid: 1731\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n#!/usr/bin/env python3\n# code_indexer_standalone.py — lightweight multi-language code indexer (no CLI)\n# Scans PROJECT_ROOT for .py, .sql, .sh; builds a compact index and writes all chunks into ONE file.\n\nfrom __future__ import annotations\nimport ast\nimport json\nimport os\nimport sys\nimport re\nimport hashlib\nimport time\nimport platform\nfrom dataclasses import dataclass, asdict\nfrom pathlib import Path\nfrom typing import Dict, List, Optional, Tuple, Union, Iterable, Set\n\n# ======================= USER SETTINGS =======================\n\n# Scan this repo (escaped backslashes; not a raw string)\nPROJECT_ROOT = Path(\"/\\\\\")\n# Where to write outputs (single chunks file + full JSON)\nOUTPUT_DIR = Path(\"/tests_adhoc\")\n\n# Max characters per printed/saved chunk marker block\nMAX_CHARS = 18000\n```\n--\nid: 1730\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n#!/usr/bin/env python3\n# code_indexer_standalone.py — lightweight multi-language code indexer (no CLI)\n# Scans PROJECT_ROOT for .py, .sql, .sh; builds a compact index and writes all chunks into ONE file.\n\nfrom __future__ import annotations\nimport ast\nimport json\nimport os\nimport sys\nimport re\nimport hashlib\nimport time\nimport platform\nfrom dataclasses import dataclass, asdict\nfrom pathlib import Path\nfrom typing import Dict, List, Optional, Tuple, Union, Iterable, Set\n\n# ======================= USER SETTINGS =======================\n\n# Scan this repo (escaped backslashes; not a raw string)\nPROJECT_ROOT = Path(\"/\\\\\")\n# Where to write outputs (single chunks file + full JSON)\nOUTPUT_DIR = Path(\"/tests_adhoc\")\n\n# Max characters per printed/saved chunk marker block\nMAX_CHARS = 18000\n```\n--\nid: 1729\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n#!/usr/bin/env python3\n# code_indexer_standalone.py — lightweight multi-language code indexer (no CLI)\n# Scans PROJECT_ROOT for .py, .sql, .sh; builds a compact index and writes all chunks into ONE file.\n\nfrom __future__ import annotations\nimport ast\nimport json\nimport os\nimport sys\nimport re\nimport hashlib\nimport time\nimport platform\nfrom dataclasses import dataclass, asdict\nfrom pathlib import Path\nfrom typing import Dict, List, Optional, Tuple, Union, Iterable, Set\n\n# ======================= USER SETTINGS =======================\n\n# Scan this repo (escaped backslashes; not a raw string)\nPROJECT_ROOT = Path(\"/\\\\\")\n# Where to write outputs (single chunks file + full JSON)\nOUTPUT_DIR = Path(\"/tests_adhoc\")\n\n# Max characters per printed/saved chunk marker block\nMAX_CHARS = 18000\n```\n--\nid: 1728\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n#!/usr/bin/env python3\n# code_indexer_standalone.py — lightweight multi-language code indexer (no CLI)\n# Scans PROJECT_ROOT for .py, .sql, .sh; builds a compact index and writes all chunks into ONE file.\n\nfrom __future__ import annotations\nimport ast\nimport json\nimport os\nimport sys\nimport re\nimport hashlib\nimport time\nimport platform\nfrom dataclasses import dataclass, asdict\nfrom pathlib import Path\nfrom typing import Dict, List, Optional, Tuple, Union, Iterable, Set\n\n# ======================= USER SETTINGS =======================\n\n# Scan this repo (escaped backslashes; not a raw string)\nPROJECT_ROOT = Path(\"/\\\\\")\n# Where to write outputs (single chunks file + full JSON)\nOUTPUT_DIR = Path(\"/tests_adhoc\")\n\n# Max characters per printed/saved chunk marker block\nMAX_CHARS = 18000\n```\n--\nid: 1727\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n#!/usr/bin/env python3\n# code_indexer_standalone.py — lightweight multi-language code indexer (no CLI)\n# Scans PROJECT_ROOT for .py, .sql, .sh; builds a compact index and writes all chunks into ONE file.\n\nfrom __future__ import annotations\nimport ast\nimport json\nimport os\nimport sys\nimport re\nimport hashlib\nimport time\nimport platform\nfrom dataclasses import dataclass, asdict\nfrom pathlib import Path\nfrom typing import Dict, List, Optional, Tuple, Union, Iterable, Set\n\n# ======================= USER SETTINGS =======================\n\n# Scan this repo (escaped backslashes; not a raw string)\nPROJECT_ROOT = Path(\"/\\\\\")\n# Where to write outputs (single chunks file + full JSON)\nOUTPUT_DIR = Path(\"/tests_adhoc\")\n\n# Max characters per printed/saved chunk marker block\nMAX_CHARS = 18000\n```\n--\nid: 1726\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n#!/usr/bin/env python3\n# code_indexer_standalone.py — lightweight multi-language code indexer (no CLI)\n# Scans PROJECT_ROOT for .py, .sql, .sh; builds a compact index and writes all chunks into ONE file.\n\nfrom __future__ import annotations\nimport ast\nimport json\nimport os\nimport sys\nimport re\nimport hashlib\nimport time\nimport platform\nfrom dataclasses import dataclass, asdict\nfrom pathlib import Path\nfrom typing import Dict, List, Optional, Tuple, Union, Iterable, Set\n\n# ======================= USER SETTINGS =======================\n\n# Scan this repo (escaped backslashes; not a raw string)\nPROJECT_ROOT = Path(\"/\\\\\")\n# Where to write outputs (single chunks file + full JSON)\nOUTPUT_DIR = Path(\"/tests_adhoc\")\n\n# Max characters per printed/saved chunk marker block\nMAX_CHARS = 18000\n```\n--\nid: 1725\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n#!/usr/bin/env python3\n# code_indexer_standalone.py — lightweight multi-language code indexer (no CLI)\n# Scans PROJECT_ROOT for .py, .sql, .sh; builds a compact index and writes all chunks into ONE file.\n\nfrom __future__ import annotations\nimport ast\nimport json\nimport os\nimport sys\nimport re\nimport hashlib\nimport time\nimport platform\nfrom dataclasses import dataclass, asdict\nfrom pathlib import Path\nfrom typing import Dict, List, Optional, Tuple, Union, Iterable, Set\n\n# ======================= USER SETTINGS =======================\n\n# Scan this repo (escaped backslashes; not a raw string)\nPROJECT_ROOT = Path(\"/\\\\\")\n# Where to write outputs (single chunks file + full JSON)\nOUTPUT_DIR = Path(\"/tests_adhoc\")\n\n# Max characters per printed/saved chunk marker block\nMAX_CHARS = 18000\n```\n--\nid: 1724\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n#!/usr/bin/env python3\n# code_indexer_standalone.py — lightweight multi-language code indexer (no CLI)\n# Scans PROJECT_ROOT for .py, .sql, .sh; builds a compact index and writes all chunks into ONE file.\n\nfrom __future__ import annotations\nimport ast\nimport json\nimport os\nimport sys\nimport re\nimport hashlib\nimport time\nimport platform\nfrom dataclasses import dataclass, asdict\nfrom pathlib import Path\nfrom typing import Dict, List, Optional, Tuple, Union, Iterable, Set\n\n# ======================= USER SETTINGS =======================\n\n# Scan this repo (escaped backslashes; not a raw string)\nPROJECT_ROOT = Path(\"/\\\\\")\n# Where to write outputs (single chunks file + full JSON)\nOUTPUT_DIR = Path(\"/tests_adhoc\")\n\n# Max characters per printed/saved chunk marker block\nMAX_CHARS = 18000\n```\n--\nid: 1723\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n#!/usr/bin/env python3\n# code_indexer_standalone.py — lightweight multi-language code indexer (no CLI)\n# Scans PROJECT_ROOT for .py, .sql, .sh; builds a compact index and writes all chunks into ONE file.\n\nfrom __future__ import annotations\nimport ast\nimport json\nimport os\nimport sys\nimport re\nimport hashlib\nimport time\nimport platform\nfrom dataclasses import dataclass, asdict\nfrom pathlib import Path\nfrom typing import Dict, List, Optional, Tuple, Union, Iterable, Set\n\n# ======================= USER SETTINGS =======================\n\n# Scan this repo (escaped backslashes; not a raw string)\nPROJECT_ROOT = Path(\"/\\\\\")\n# Where to write outputs (single chunks file + full JSON)\nOUTPUT_DIR = Path(\"/tests_adhoc\")\n\n# Max characters per printed/saved chunk marker block\nMAX_CHARS = 18000\n```\n--\nid: 1722\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n#!/usr/bin/env python3\n# code_indexer_standalone.py — lightweight multi-language code indexer (no CLI)\n# Scans PROJECT_ROOT for .py, .sql, .sh; builds a compact index and writes all chunks into ONE file.\n\nfrom __future__ import annotations\nimport ast\nimport json\nimport os\nimport sys\nimport re\nimport hashlib\nimport time\nimport platform\nfrom dataclasses import dataclass, asdict\nfrom pathlib import Path\nfrom typing import Dict, List, Optional, Tuple, Union, Iterable, Set\n\n# ======================= USER SETTINGS =======================\n\n# Scan this repo (escaped backslashes; not a raw string)\nPROJECT_ROOT = Path(\"/\\\\\")\n# Where to write outputs (single chunks file + full JSON)\nOUTPUT_DIR = Path(\"/tests_adhoc\")\n\n# Max characters per printed/saved chunk marker block\nMAX_CHARS = 18000\n```\n--\nid: 1721\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n#!/usr/bin/env python3\n# code_indexer_standalone.py — lightweight multi-language code indexer (no CLI)\n# Scans PROJECT_ROOT for .py, .sql, .sh; builds a compact index and writes all chunks into ONE file.\n\nfrom __future__ import annotations\nimport ast\nimport json\nimport os\nimport sys\nimport re\nimport hashlib\nimport time\nimport platform\nfrom dataclasses import dataclass, asdict\nfrom pathlib import Path\nfrom typing import Dict, List, Optional, Tuple, Union, Iterable, Set\n\n# ======================= USER SETTINGS =======================\n\n# Scan this repo (escaped backslashes; not a raw string)\nPROJECT_ROOT = Path(\"/\\\\\")\n# Where to write outputs (single chunks file + full JSON)\nOUTPUT_DIR = Path(\"/tests_adhoc\")\n\n# Max characters per printed/saved chunk marker block\nMAX_CHARS = 18000\n```\n--\nid: 1720\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n#!/usr/bin/env python3\n# code_indexer_standalone.py — lightweight multi-language code indexer (no CLI)\n# Scans PROJECT_ROOT for .py, .sql, .sh; builds a compact index and writes all chunks into ONE file.\n\nfrom __future__ import annotations\nimport ast\nimport json\nimport os\nimport sys\nimport re\nimport hashlib\nimport time\nimport platform\nfrom dataclasses import dataclass, asdict\nfrom pathlib import Path\nfrom typing import Dict, List, Optional, Tuple, Union, Iterable, Set\n\n# ======================= USER SETTINGS =======================\n\n# Scan this repo (escaped backslashes; not a raw string)\nPROJECT_ROOT = Path(\"/\\\\\")\n# Where to write outputs (single chunks file + full JSON)\nOUTPUT_DIR = Path(\"/tests_adhoc\")\n\n# Max characters per printed/saved chunk marker block\nMAX_CHARS = 18000\n```\n--\nid: 1719\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n#!/usr/bin/env python3\n# code_indexer_standalone.py — lightweight multi-language code indexer (no CLI)\n# Scans PROJECT_ROOT for .py, .sql, .sh; builds a compact index and writes all chunks into ONE file.\n\nfrom __future__ import annotations\nimport ast\nimport json\nimport os\nimport sys\nimport re\nimport hashlib\nimport time\nimport platform\nfrom dataclasses import dataclass, asdict\nfrom pathlib import Path\nfrom typing import Dict, List, Optional, Tuple, Union, Iterable, Set\n\n# ======================= USER SETTINGS =======================\n\n# Scan this repo (escaped backslashes; not a raw string)\nPROJECT_ROOT = Path(\"/\\\\\")\n# Where to write outputs (single chunks file + full JSON)\nOUTPUT_DIR = Path(\"/tests_adhoc\")\n\n# Max characters per printed/saved chunk marker block\nMAX_CHARS = 18000\n```\n--\nid: 1718\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n#!/usr/bin/env python3\n# code_indexer_standalone.py — lightweight multi-language code indexer (no CLI)\n# Scans PROJECT_ROOT for .py, .sql, .sh; builds a compact index and writes all chunks into ONE file.\n\nfrom __future__ import annotations\nimport ast\nimport json\nimport os\nimport sys\nimport re\nimport hashlib\nimport time\nimport platform\nfrom dataclasses import dataclass, asdict\nfrom pathlib import Path\nfrom typing import Dict, List, Optional, Tuple, Union, Iterable, Set\n\n# ======================= USER SETTINGS =======================\n\n# Scan this repo (escaped backslashes; not a raw string)\nPROJECT_ROOT = Path(\"/\\\\\")\n# Where to write outputs (single chunks file + full JSON)\nOUTPUT_DIR = Path(\"/tests_adhoc\")\n\n# Max characters per printed/saved chunk marker block\nMAX_CHARS = 18000\n```\n--\nid: 1717\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n#!/usr/bin/env python3\n# code_indexer_standalone.py — lightweight multi-language code indexer (no CLI)\n# Scans PROJECT_ROOT for .py, .sql, .sh; builds a compact index and writes all chunks into ONE file.\n\nfrom __future__ import annotations\nimport ast\nimport json\nimport os\nimport sys\nimport re\nimport hashlib\nimport time\nimport platform\nfrom dataclasses import dataclass, asdict\nfrom pathlib import Path\nfrom typing import Dict, List, Optional, Tuple, Union, Iterable, Set\n\n# ======================= USER SETTINGS =======================\n\n# Scan this repo (escaped backslashes; not a raw string)\nPROJECT_ROOT = Path(\"/\\\\\")\n# Where to write outputs (single chunks file + full JSON)\nOUTPUT_DIR = Path(\"/tests_adhoc\")\n\n# Max characters per printed/saved chunk marker block\nMAX_CHARS = 18000\n```\n--\nid: 1716\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n#!/usr/bin/env python3\n# code_indexer_standalone.py — lightweight multi-language code indexer (no CLI)\n# Scans PROJECT_ROOT for .py, .sql, .sh; builds a compact index and writes all chunks into ONE file.\n\nfrom __future__ import annotations\nimport ast\nimport json\nimport os\nimport sys\nimport re\nimport hashlib\nimport time\nimport platform\nfrom dataclasses import dataclass, asdict\nfrom pathlib import Path\nfrom typing import Dict, List, Optional, Tuple, Union, Iterable, Set\n\n# ======================= USER SETTINGS =======================\n\n# Scan this repo (escaped backslashes; not a raw string)\nPROJECT_ROOT = Path(\"/\\\\\")\n# Where to write outputs (single chunks file + full JSON)\nOUTPUT_DIR = Path(\"/tests_adhoc\")\n\n# Max characters per printed/saved chunk marker block\nMAX_CHARS = 18000\n```\n--\nid: 1715\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n#!/usr/bin/env python3\n# code_indexer_standalone.py — lightweight multi-language code indexer (no CLI)\n# Scans PROJECT_ROOT for .py, .sql, .sh; builds a compact index and writes all chunks into ONE file.\n\nfrom __future__ import annotations\nimport ast\nimport json\nimport os\nimport sys\nimport re\nimport hashlib\nimport time\nimport platform\nfrom dataclasses import dataclass, asdict\nfrom pathlib import Path\nfrom typing import Dict, List, Optional, Tuple, Union, Iterable, Set\n\n# ======================= USER SETTINGS =======================\n\n# Scan this repo (escaped backslashes; not a raw string)\nPROJECT_ROOT = Path(\"/\\\\\")\n# Where to write outputs (single chunks file + full JSON)\nOUTPUT_DIR = Path(\"/tests_adhoc\")\n\n# Max characters per printed/saved chunk marker block\nMAX_CHARS = 18000\n```\n--\nid: 1714\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n#!/usr/bin/env python3\n# code_indexer_standalone.py — lightweight multi-language code indexer (no CLI)\n# Scans PROJECT_ROOT for .py, .sql, .sh; builds a compact index and writes all chunks into ONE file.\n\nfrom __future__ import annotations\nimport ast\nimport json\nimport os\nimport sys\nimport re\nimport hashlib\nimport time\nimport platform\nfrom dataclasses import dataclass, asdict\nfrom pathlib import Path\nfrom typing import Dict, List, Optional, Tuple, Union, Iterable, Set\n\n# ======================= USER SETTINGS =======================\n\n# Scan this repo (escaped backslashes; not a raw string)\nPROJECT_ROOT = Path(\"/\\\\\")\n# Where to write outputs (single chunks file + full JSON)\nOUTPUT_DIR = Path(\"/tests_adhoc\")\n\n# Max characters per printed/saved chunk marker block\nMAX_CHARS = 18000\n```\n--\nid: 1713\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n#!/usr/bin/env python3\n# code_indexer_standalone.py — lightweight multi-language code indexer (no CLI)\n# Scans PROJECT_ROOT for .py, .sql, .sh; builds a compact index and writes all chunks into ONE file.\n\nfrom __future__ import annotations\nimport ast\nimport json\nimport os\nimport sys\nimport re\nimport hashlib\nimport time\nimport platform\nfrom dataclasses import dataclass, asdict\nfrom pathlib import Path\nfrom typing import Dict, List, Optional, Tuple, Union, Iterable, Set\n\n# ======================= USER SETTINGS =======================\n\n# Scan this repo (escaped backslashes; not a raw string)\nPROJECT_ROOT = Path(\"/\\\\\")\n# Where to write outputs (single chunks file + full JSON)\nOUTPUT_DIR = Path(\"/tests_adhoc\")\n\n# Max characters per printed/saved chunk marker block\nMAX_CHARS = 18000\n```\n--\nid: 1712\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n#!/usr/bin/env python3\n# code_indexer_standalone.py — lightweight multi-language code indexer (no CLI)\n# Scans PROJECT_ROOT for .py, .sql, .sh; builds a compact index and writes all chunks into ONE file.\n\nfrom __future__ import annotations\nimport ast\nimport json\nimport os\nimport sys\nimport re\nimport hashlib\nimport time\nimport platform\nfrom dataclasses import dataclass, asdict\nfrom pathlib import Path\nfrom typing import Dict, List, Optional, Tuple, Union, Iterable, Set\n\n# ======================= USER SETTINGS =======================\n\n# Scan this repo (escaped backslashes; not a raw string)\nPROJECT_ROOT = Path(\"/\\\\\")\n# Where to write outputs (single chunks file + full JSON)\nOUTPUT_DIR = Path(\"/tests_adhoc\")\n\n# Max characters per printed/saved chunk marker block\nMAX_CHARS = 18000\n```\n--\nid: 1711\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n#!/usr/bin/env python3\n# code_indexer_standalone.py — lightweight multi-language code indexer (no CLI)\n# Scans PROJECT_ROOT for .py, .sql, .sh; builds a compact index and writes all chunks into ONE file.\n\nfrom __future__ import annotations\nimport ast\nimport json\nimport os\nimport sys\nimport re\nimport hashlib\nimport time\nimport platform\nfrom dataclasses import dataclass, asdict\nfrom pathlib import Path\nfrom typing import Dict, List, Optional, Tuple, Union, Iterable, Set\n\n# ======================= USER SETTINGS =======================\n\n# Scan this repo (escaped backslashes; not a raw string)\nPROJECT_ROOT = Path(\"/\\\\\")\n# Where to write outputs (single chunks file + full JSON)\nOUTPUT_DIR = Path(\"/tests_adhoc\")\n\n# Max characters per printed/saved chunk marker block\nMAX_CHARS = 18000\n```\n--\nid: 1710\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n#!/usr/bin/env python3\n# code_indexer_standalone.py — lightweight multi-language code indexer (no CLI)\n# Scans PROJECT_ROOT for .py, .sql, .sh; builds a compact index and writes all chunks into ONE file.\n\nfrom __future__ import annotations\nimport ast\nimport json\nimport os\nimport sys\nimport re\nimport hashlib\nimport time\nimport platform\nfrom dataclasses import dataclass, asdict\nfrom pathlib import Path\nfrom typing import Dict, List, Optional, Tuple, Union, Iterable, Set\n\n# ======================= USER SETTINGS =======================\n\n# Scan this repo (escaped backslashes; not a raw string)\nPROJECT_ROOT = Path(\"/\\\\\")\n# Where to write outputs (single chunks file + full JSON)\nOUTPUT_DIR = Path(\"/tests_adhoc\")\n\n# Max characters per printed/saved chunk marker block\nMAX_CHARS = 18000\n```\n--\nid: 1709\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n#!/usr/bin/env python3\n# code_indexer_standalone.py — lightweight multi-language code indexer (no CLI)\n# Scans PROJECT_ROOT for .py, .sql, .sh; builds a compact index and writes all chunks into ONE file.\n\nfrom __future__ import annotations\nimport ast\nimport json\nimport os\nimport sys\nimport re\nimport hashlib\nimport time\nimport platform\nfrom dataclasses import dataclass, asdict\nfrom pathlib import Path\nfrom typing import Dict, List, Optional, Tuple, Union, Iterable, Set\n\n# ======================= USER SETTINGS =======================\n\n# Scan this repo (escaped backslashes; not a raw string)\nPROJECT_ROOT = Path(\"/\\\\\")\n# Where to write outputs (single chunks file + full JSON)\nOUTPUT_DIR = Path(\"/tests_adhoc\")\n\n# Max characters per printed/saved chunk marker block\nMAX_CHARS = 18000\n```\n--\nid: 1708\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n#!/usr/bin/env python3\n# code_indexer_standalone.py — lightweight multi-language code indexer (no CLI)\n# Scans PROJECT_ROOT for .py, .sql, .sh; builds a compact index and writes all chunks into ONE file.\n\nfrom __future__ import annotations\nimport ast\nimport json\nimport os\nimport sys\nimport re\nimport hashlib\nimport time\nimport platform\nfrom dataclasses import dataclass, asdict\nfrom pathlib import Path\nfrom typing import Dict, List, Optional, Tuple, Union, Iterable, Set\n\n# ======================= USER SETTINGS =======================\n\n# Scan this repo (escaped backslashes; not a raw string)\nPROJECT_ROOT = Path(\"/\\\\\")\n# Where to write outputs (single chunks file + full JSON)\nOUTPUT_DIR = Path(\"/tests_adhoc\")\n\n# Max characters per printed/saved chunk marker block\nMAX_CHARS = 18000\n```\n--\nid: 1707\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n#!/usr/bin/env python3\n# code_indexer_standalone.py — lightweight multi-language code indexer (no CLI)\n# Scans PROJECT_ROOT for .py, .sql, .sh; builds a compact index and writes all chunks into ONE file.\n\nfrom __future__ import annotations\nimport ast\nimport json\nimport os\nimport sys\nimport re\nimport hashlib\nimport time\nimport platform\nfrom dataclasses import dataclass, asdict\nfrom pathlib import Path\nfrom typing import Dict, List, Optional, Tuple, Union, Iterable, Set\n\n# ======================= USER SETTINGS =======================\n\n# Scan this repo (escaped backslashes; not a raw string)\nPROJECT_ROOT = Path(\"/\\\\\")\n# Where to write outputs (single chunks file + full JSON)\nOUTPUT_DIR = Path(\"/tests_adhoc\")\n\n# Max characters per printed/saved chunk marker block\nMAX_CHARS = 18000\n```\n--\nid: 1706\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n#!/usr/bin/env python3\n# code_indexer_standalone.py — lightweight multi-language code indexer (no CLI)\n# Scans PROJECT_ROOT for .py, .sql, .sh; builds a compact index and writes all chunks into ONE file.\n\nfrom __future__ import annotations\nimport ast\nimport json\nimport os\nimport sys\nimport re\nimport hashlib\nimport time\nimport platform\nfrom dataclasses import dataclass, asdict\nfrom pathlib import Path\nfrom typing import Dict, List, Optional, Tuple, Union, Iterable, Set\n\n# ======================= USER SETTINGS =======================\n\n# Scan this repo (escaped backslashes; not a raw string)\nPROJECT_ROOT = Path(\"/\\\\\")\n# Where to write outputs (single chunks file + full JSON)\nOUTPUT_DIR = Path(\"/tests_adhoc\")\n\n# Max characters per printed/saved chunk marker block\nMAX_CHARS = 18000\n```\n--\nid: 1705\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n#!/usr/bin/env python3\n# code_indexer_standalone.py — lightweight multi-language code indexer (no CLI)\n# Scans PROJECT_ROOT for .py, .sql, .sh; builds a compact index and writes all chunks into ONE file.\n\nfrom __future__ import annotations\nimport ast\nimport json\nimport os\nimport sys\nimport re\nimport hashlib\nimport time\nimport platform\nfrom dataclasses import dataclass, asdict\nfrom pathlib import Path\nfrom typing import Dict, List, Optional, Tuple, Union, Iterable, Set\n\n# ======================= USER SETTINGS =======================\n\n# Scan this repo (escaped backslashes; not a raw string)\nPROJECT_ROOT = Path(\"/\\\\\")\n# Where to write outputs (single chunks file + full JSON)\nOUTPUT_DIR = Path(\"/tests_adhoc\")\n\n# Max characters per printed/saved chunk marker block\nMAX_CHARS = 18000\n```\n--\nid: 1704\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n#!/usr/bin/env python3\n# code_indexer_standalone.py — lightweight multi-language code indexer (no CLI)\n# Scans PROJECT_ROOT for .py, .sql, .sh; builds a compact index and writes all chunks into ONE file.\n\nfrom __future__ import annotations\nimport ast\nimport json\nimport os\nimport sys\nimport re\nimport hashlib\nimport time\nimport platform\nfrom dataclasses import dataclass, asdict\nfrom pathlib import Path\nfrom typing import Dict, List, Optional, Tuple, Union, Iterable, Set\n\n# ======================= USER SETTINGS =======================\n\n# Scan this repo (escaped backslashes; not a raw string)\nPROJECT_ROOT = Path(\"/\\\\\")\n# Where to write outputs (single chunks file + full JSON)\nOUTPUT_DIR = Path(\"/tests_adhoc\")\n\n# Max characters per printed/saved chunk marker block\nMAX_CHARS = 18000\n```\n--\nid: 1703\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n#!/usr/bin/env python3\n# code_indexer_standalone.py — lightweight multi-language code indexer (no CLI)\n# Scans PROJECT_ROOT for .py, .sql, .sh; builds a compact index and writes all chunks into ONE file.\n\nfrom __future__ import annotations\nimport ast\nimport json\nimport os\nimport sys\nimport re\nimport hashlib\nimport time\nimport platform\nfrom dataclasses import dataclass, asdict\nfrom pathlib import Path\nfrom typing import Dict, List, Optional, Tuple, Union, Iterable, Set\n\n# ======================= USER SETTINGS =======================\n\n# Scan this repo (escaped backslashes; not a raw string)\nPROJECT_ROOT = Path(\"/\\\\\")\n# Where to write outputs (single chunks file + full JSON)\nOUTPUT_DIR = Path(\"/tests_adhoc\")\n\n# Max characters per printed/saved chunk marker block\nMAX_CHARS = 18000\n```\n--\nid: 1702\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n#!/usr/bin/env python3\n# code_indexer_standalone.py — lightweight multi-language code indexer (no CLI)\n# Scans PROJECT_ROOT for .py, .sql, .sh; builds a compact index and writes all chunks into ONE file.\n\nfrom __future__ import annotations\nimport ast\nimport json\nimport os\nimport sys\nimport re\nimport hashlib\nimport time\nimport platform\nfrom dataclasses import dataclass, asdict\nfrom pathlib import Path\nfrom typing import Dict, List, Optional, Tuple, Union, Iterable, Set\n\n# ======================= USER SETTINGS =======================\n\n# Scan this repo (escaped backslashes; not a raw string)\nPROJECT_ROOT = Path(\"/\\\\\")\n# Where to write outputs (single chunks file + full JSON)\nOUTPUT_DIR = Path(\"/tests_adhoc\")\n\n# Max characters per printed/saved chunk marker block\nMAX_CHARS = 18000\n```\n--\nid: 1701\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n#!/usr/bin/env python3\n# code_indexer_standalone.py — lightweight multi-language code indexer (no CLI)\n# Scans PROJECT_ROOT for .py, .sql, .sh; builds a compact index and writes all chunks into ONE file.\n\nfrom __future__ import annotations\nimport ast\nimport json\nimport os\nimport sys\nimport re\nimport hashlib\nimport time\nimport platform\nfrom dataclasses import dataclass, asdict\nfrom pathlib import Path\nfrom typing import Dict, List, Optional, Tuple, Union, Iterable, Set\n\n# ======================= USER SETTINGS =======================\n\n# Scan this repo (escaped backslashes; not a raw string)\nPROJECT_ROOT = Path(\"/\\\\\")\n# Where to write outputs (single chunks file + full JSON)\nOUTPUT_DIR = Path(\"/tests_adhoc\")\n\n# Max characters per printed/saved chunk marker block\nMAX_CHARS = 18000\n```\n--\nid: 1700\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n#!/usr/bin/env python3\n# code_indexer_standalone.py — lightweight multi-language code indexer (no CLI)\n# Scans PROJECT_ROOT for .py, .sql, .sh; builds a compact index and writes all chunks into ONE file.\n\nfrom __future__ import annotations\nimport ast\nimport json\nimport os\nimport sys\nimport re\nimport hashlib\nimport time\nimport platform\nfrom dataclasses import dataclass, asdict\nfrom pathlib import Path\nfrom typing import Dict, List, Optional, Tuple, Union, Iterable, Set\n\n# ======================= USER SETTINGS =======================\n\n# Scan this repo (escaped backslashes; not a raw string)\nPROJECT_ROOT = Path(\"/\\\\\")\n# Where to write outputs (single chunks file + full JSON)\nOUTPUT_DIR = Path(\"/tests_adhoc\")\n\n# Max characters per printed/saved chunk marker block\nMAX_CHARS = 18000\n```\n--\nid: 1699\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n#!/usr/bin/env python3\n# code_indexer_standalone.py — lightweight multi-language code indexer (no CLI)\n# Scans PROJECT_ROOT for .py, .sql, .sh; builds a compact index and writes all chunks into ONE file.\n\nfrom __future__ import annotations\nimport ast\nimport json\nimport os\nimport sys\nimport re\nimport hashlib\nimport time\nimport platform\nfrom dataclasses import dataclass, asdict\nfrom pathlib import Path\nfrom typing import Dict, List, Optional, Tuple, Union, Iterable, Set\n\n# ======================= USER SETTINGS =======================\n\n# Scan this repo (escaped backslashes; not a raw string)\nPROJECT_ROOT = Path(\"/\\\\\")\n# Where to write outputs (single chunks file + full JSON)\nOUTPUT_DIR = Path(\"/tests_adhoc\")\n\n# Max characters per printed/saved chunk marker block\nMAX_CHARS = 18000\n```\n--\nid: 1698\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n#!/usr/bin/env python3\n# code_indexer_standalone.py — lightweight multi-language code indexer (no CLI)\n# Scans PROJECT_ROOT for .py, .sql, .sh; builds a compact index and writes all chunks into ONE file.\n\nfrom __future__ import annotations\nimport ast\nimport json\nimport os\nimport sys\nimport re\nimport hashlib\nimport time\nimport platform\nfrom dataclasses import dataclass, asdict\nfrom pathlib import Path\nfrom typing import Dict, List, Optional, Tuple, Union, Iterable, Set\n\n# ======================= USER SETTINGS =======================\n\n# Scan this repo (escaped backslashes; not a raw string)\nPROJECT_ROOT = Path(\"/\\\\\")\n# Where to write outputs (single chunks file + full JSON)\nOUTPUT_DIR = Path(\"/tests_adhoc\")\n\n# Max characters per printed/saved chunk marker block\nMAX_CHARS = 18000\n```\n--\nid: 1697\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\nfrom __future__ import annotations\n\ndef _one_line(s: str, max_len: int = 160) -> str:\n    s = \" \".join((s or \"\").split())\n    return s[:max_len] + (\"…\" if len(s) > max_len else \"\")\n\nclass ConsoleLog:\n    def __init__(self, tag: str):\n        self.tag = tag\n\n    def info(self, msg: str):\n        print(f\"[{self.tag} ✅] {_one_line(msg)}\")\n\n    def warn(self, msg: str):\n        print(f\"[{self.tag} ⚠️] {_one_line(msg)}\")\n\n    def error(self, msg: str):\n        print(f\"[{self.tag} ❌] {_one_line(msg)}\")\n\n    def stage(self, emoji: str, msg: str):\n        print(f\"[{self.tag} {emoji}] {_one_line(msg)}\")\n```\n--\nid: 1696\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\nfrom __future__ import annotations\n\ndef _one_line(s: str, max_len: int = 160) -> str:\n    s = \" \".join((s or \"\").split())\n    return s[:max_len] + (\"…\" if len(s) > max_len else \"\")\n\nclass ConsoleLog:\n    def __init__(self, tag: str):\n        self.tag = tag\n\n    def info(self, msg: str):\n        print(f\"[{self.tag} ✅] {_one_line(msg)}\")\n\n    def warn(self, msg: str):\n        print(f\"[{self.tag} ⚠️] {_one_line(msg)}\")\n\n    def error(self, msg: str):\n        print(f\"[{self.tag} ❌] {_one_line(msg)}\")\n\n    def stage(self, emoji: str, msg: str):\n        print(f\"[{self.tag} {emoji}] {_one_line(msg)}\")\n```\n--\nid: 1695\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\nfrom __future__ import annotations\n\ndef _one_line(s: str, max_len: int = 160) -> str:\n    s = \" \".join((s or \"\").split())\n    return s[:max_len] + (\"…\" if len(s) > max_len else \"\")\n\nclass ConsoleLog:\n    def __init__(self, tag: str):\n        self.tag = tag\n\n    def info(self, msg: str):\n        print(f\"[{self.tag} ✅] {_one_line(msg)}\")\n\n    def warn(self, msg: str):\n        print(f\"[{self.tag} ⚠️] {_one_line(msg)}\")\n\n    def error(self, msg: str):\n        print(f\"[{self.tag} ❌] {_one_line(msg)}\")\n\n    def stage(self, emoji: str, msg: str):\n        print(f\"[{self.tag} {emoji}] {_one_line(msg)}\")\n```\n--\nid: 1694\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\nfrom __future__ import annotations\n\ndef _one_line(s: str, max_len: int = 160) -> str:\n    s = \" \".join((s or \"\").split())\n    return s[:max_len] + (\"…\" if len(s) > max_len else \"\")\n\nclass ConsoleLog:\n    def __init__(self, tag: str):\n        self.tag = tag\n\n    def info(self, msg: str):\n        print(f\"[{self.tag} ✅] {_one_line(msg)}\")\n\n    def warn(self, msg: str):\n        print(f\"[{self.tag} ⚠️] {_one_line(msg)}\")\n\n    def error(self, msg: str):\n        print(f\"[{self.tag} ❌] {_one_line(msg)}\")\n\n    def stage(self, emoji: str, msg: str):\n        print(f\"[{self.tag} {emoji}] {_one_line(msg)}\")\n```\n--\nid: 1693\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\nfrom __future__ import annotations\n\ndef _one_line(s: str, max_len: int = 160) -> str:\n    s = \" \".join((s or \"\").split())\n    return s[:max_len] + (\"…\" if len(s) > max_len else \"\")\n\nclass ConsoleLog:\n    def __init__(self, tag: str):\n        self.tag = tag\n\n    def info(self, msg: str):\n        print(f\"[{self.tag} ✅] {_one_line(msg)}\")\n\n    def warn(self, msg: str):\n        print(f\"[{self.tag} ⚠️] {_one_line(msg)}\")\n\n    def error(self, msg: str):\n        print(f\"[{self.tag} ❌] {_one_line(msg)}\")\n\n    def stage(self, emoji: str, msg: str):\n        print(f\"[{self.tag} {emoji}] {_one_line(msg)}\")\n```\n--\nid: 1692\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\nfrom __future__ import annotations\n\ndef _one_line(s: str, max_len: int = 160) -> str:\n    s = \" \".join((s or \"\").split())\n    return s[:max_len] + (\"…\" if len(s) > max_len else \"\")\n\nclass ConsoleLog:\n    def __init__(self, tag: str):\n        self.tag = tag\n\n    def info(self, msg: str):\n        print(f\"[{self.tag} ✅] {_one_line(msg)}\")\n\n    def warn(self, msg: str):\n        print(f\"[{self.tag} ⚠️] {_one_line(msg)}\")\n\n    def error(self, msg: str):\n        print(f\"[{self.tag} ❌] {_one_line(msg)}\")\n\n    def stage(self, emoji: str, msg: str):\n        print(f\"[{self.tag} {emoji}] {_one_line(msg)}\")\n```\n--\nid: 1691\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\nfrom __future__ import annotations\n\ndef _one_line(s: str, max_len: int = 160) -> str:\n    s = \" \".join((s or \"\").split())\n    return s[:max_len] + (\"…\" if len(s) > max_len else \"\")\n\nclass ConsoleLog:\n    def __init__(self, tag: str):\n        self.tag = tag\n\n    def info(self, msg: str):\n        print(f\"[{self.tag} ✅] {_one_line(msg)}\")\n\n    def warn(self, msg: str):\n        print(f\"[{self.tag} ⚠️] {_one_line(msg)}\")\n\n    def error(self, msg: str):\n        print(f\"[{self.tag} ❌] {_one_line(msg)}\")\n\n    def stage(self, emoji: str, msg: str):\n        print(f\"[{self.tag} {emoji}] {_one_line(msg)}\")\n```\n--\nid: 1690\nmode: rewrite\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n\"\"\"Filesystem IO helpers.\"\"\"\n```\n--\nid: 1689\nmode: create\nsignature: module\ndescription: \"Creates a run directory without a dedicated /patches subdir.\"\ncontext_code:\n```python\n# File: backend/core/utils/io/run_dir.py\nfrom __future__ import annotations\n\nfrom dataclasses import dataclass\nfrom datetime import datetime\nfrom pathlib import Path\nfrom typing import Optional\n\n\n@dataclass\nclass RunDirs:\n    out_base: Path\n\n    def make_run_id(self, suffix: Optional[str] = None) -> str:\n        ts = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n        return f\"{ts}_{suffix}\" if suffix else ts\n\n    def ensure(self, run_id: str):\n        \"\"\"\n        Create a run directory with **no dedicated /patches subdir**.\n        We still provision common locations that are written by the pipeline,\n        but all artifacts remain inside this single run root.\n        \"\"\"\n        root = self.out_base / run_id\n        sub = [\n            \"archives\",\n```\n--\nid: 1688\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n# File: backend/core/utils/io/run_dir.py\nfrom __future__ import annotations\n\nfrom dataclasses import dataclass\nfrom datetime import datetime\nfrom pathlib import Path\nfrom typing import Optional\n\n\n@dataclass\nclass RunDirs:\n    out_base: Path\n\n    def make_run_id(self, suffix: Optional[str] = None) -> str:\n        ts = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n        return f\"{ts}_{suffix}\" if suffix else ts\n\n    def ensure(self, run_id: str):\n        \"\"\"\n        Create a run directory with **no dedicated /patches subdir**.\n        We still provision common locations that are written by the pipeline,\n        but all artifacts remain inside this single run root.\n        \"\"\"\n        root = self.out_base / run_id\n        sub = [\n            \"archives\",\n```\n--\nid: 1687\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n# File: backend/core/utils/io/run_dir.py\nfrom __future__ import annotations\n\nfrom dataclasses import dataclass\nfrom datetime import datetime\nfrom pathlib import Path\nfrom typing import Optional\n\n\n@dataclass\nclass RunDirs:\n    out_base: Path\n\n    def make_run_id(self, suffix: Optional[str] = None) -> str:\n        ts = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n        return f\"{ts}_{suffix}\" if suffix else ts\n\n    def ensure(self, run_id: str):\n        \"\"\"\n        Create a run directory with **no dedicated /patches subdir**.\n        We still provision common locations that are written by the pipeline,\n        but all artifacts remain inside this single run root.\n        \"\"\"\n        root = self.out_base / run_id\n        sub = [\n            \"archives\",\n```\n--\nid: 1686\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n#!/usr/bin/env python3\nimport os\nimport zipfile\n\n# ==== CONFIG ====\nSOURCE_FOLDER = r\"C:\\Users\\cg371\\Code Repos\\Lineage\"     # Folder to zip\nOUTPUT_ZIP = r\"C:\\Users\\cg371\\Code Repos\\Lineage.zip\"    # Output archive path\n# ================\n\ndef zip_directory(folder_path, output_filename):\n    folder_path = os.path.abspath(folder_path)\n    top_dir_name = os.path.basename(folder_path.rstrip(os.sep))\n\n    with zipfile.ZipFile(output_filename, 'w', zipfile.ZIP_DEFLATED) as zipf:\n        for root, dirs, files in os.walk(folder_path):\n            for file in files:\n                abs_file_path = os.path.join(root, file)\n                # Ensure top_dir_name is the root folder in the archive\n                rel_path_in_zip = os.path.join(top_dir_name, os.path.relpath(abs_file_path, folder_path))\n                zipf.write(abs_file_path, rel_path_in_zip)\n\n    print(f\"Created archive: {output_filename}\")\n\nif __name__ == \"__main__\":\n    if not os.path.isdir(SOURCE_FOLDER):\n        raise ValueError(f\"Source folder does not exist: {SOURCE_FOLDER}\")\n```\n--\nid: 1685\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\nfrom __future__ import annotations\nfrom dataclasses import dataclass\nfrom pathlib import Path\nimport json, csv\nfrom typing import Dict, Any, List\nfrom .file_ops import FileOps, FileOpsConfig\n\n@dataclass\nclass OutputWriter:\n    root: Path\n    def __post_init__(self):\n        self.fo = FileOps(FileOpsConfig())\n        (self.root / \"items\").mkdir(parents=True, exist_ok=True)\n        (self.root / \"batches\").mkdir(exist_ok=True)\n        self._summary = self.root / \"summary.csv\"\n        if not self._summary.exists():\n            with self._summary.open(\"w\", newline=\"\", encoding=\"utf-8\") as f:\n                csv.writer(f).writerow([\"id\",\"path\",\"signature\",\"outfile\",\"ok\",\"error\"])\n\n    def write_item(self, item: Dict[str, Any]) -> Path:\n        p = self.root / \"items\" / f\"{item['id']}.json\"\n        self.fo.write_text(p, json.dumps(item, ensure_ascii=False, indent=2)); return p\n\n    def append_batch(self, items: List[Dict[str, Any]]) -> Path:\n        p = self.root / \"batches\" / \"batches.jsonl\"\n        with p.open(\"a\", encoding=\"utf-8\") as f:\n```\n--\nid: 1684\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\nfrom __future__ import annotations\nfrom dataclasses import dataclass\nfrom pathlib import Path\nimport json, csv\nfrom typing import Dict, Any, List\nfrom .file_ops import FileOps, FileOpsConfig\n\n@dataclass\nclass OutputWriter:\n    root: Path\n    def __post_init__(self):\n        self.fo = FileOps(FileOpsConfig())\n        (self.root / \"items\").mkdir(parents=True, exist_ok=True)\n        (self.root / \"batches\").mkdir(exist_ok=True)\n        self._summary = self.root / \"summary.csv\"\n        if not self._summary.exists():\n            with self._summary.open(\"w\", newline=\"\", encoding=\"utf-8\") as f:\n                csv.writer(f).writerow([\"id\",\"path\",\"signature\",\"outfile\",\"ok\",\"error\"])\n\n    def write_item(self, item: Dict[str, Any]) -> Path:\n        p = self.root / \"items\" / f\"{item['id']}.json\"\n        self.fo.write_text(p, json.dumps(item, ensure_ascii=False, indent=2)); return p\n\n    def append_batch(self, items: List[Dict[str, Any]]) -> Path:\n        p = self.root / \"batches\" / \"batches.jsonl\"\n        with p.open(\"a\", encoding=\"utf-8\") as f:\n```\n--\nid: 1683\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\nfrom __future__ import annotations\nfrom dataclasses import dataclass\nfrom pathlib import Path\nimport json, csv\nfrom typing import Dict, Any, List\nfrom .file_ops import FileOps, FileOpsConfig\n\n@dataclass\nclass OutputWriter:\n    root: Path\n    def __post_init__(self):\n        self.fo = FileOps(FileOpsConfig())\n        (self.root / \"items\").mkdir(parents=True, exist_ok=True)\n        (self.root / \"batches\").mkdir(exist_ok=True)\n        self._summary = self.root / \"summary.csv\"\n        if not self._summary.exists():\n            with self._summary.open(\"w\", newline=\"\", encoding=\"utf-8\") as f:\n                csv.writer(f).writerow([\"id\",\"path\",\"signature\",\"outfile\",\"ok\",\"error\"])\n\n    def write_item(self, item: Dict[str, Any]) -> Path:\n        p = self.root / \"items\" / f\"{item['id']}.json\"\n        self.fo.write_text(p, json.dumps(item, ensure_ascii=False, indent=2)); return p\n\n    def append_batch(self, items: List[Dict[str, Any]]) -> Path:\n        p = self.root / \"batches\" / \"batches.jsonl\"\n        with p.open(\"a\", encoding=\"utf-8\") as f:\n```\n--\nid: 1682\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\nfrom __future__ import annotations\nfrom dataclasses import dataclass\nfrom pathlib import Path\nimport json, csv\nfrom typing import Dict, Any, List\nfrom .file_ops import FileOps, FileOpsConfig\n\n@dataclass\nclass OutputWriter:\n    root: Path\n    def __post_init__(self):\n        self.fo = FileOps(FileOpsConfig())\n        (self.root / \"items\").mkdir(parents=True, exist_ok=True)\n        (self.root / \"batches\").mkdir(exist_ok=True)\n        self._summary = self.root / \"summary.csv\"\n        if not self._summary.exists():\n            with self._summary.open(\"w\", newline=\"\", encoding=\"utf-8\") as f:\n                csv.writer(f).writerow([\"id\",\"path\",\"signature\",\"outfile\",\"ok\",\"error\"])\n\n    def write_item(self, item: Dict[str, Any]) -> Path:\n        p = self.root / \"items\" / f\"{item['id']}.json\"\n        self.fo.write_text(p, json.dumps(item, ensure_ascii=False, indent=2)); return p\n\n    def append_batch(self, items: List[Dict[str, Any]]) -> Path:\n        p = self.root / \"batches\" / \"batches.jsonl\"\n        with p.open(\"a\", encoding=\"utf-8\") as f:\n```\n--\nid: 1681\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\nfrom __future__ import annotations\nfrom dataclasses import dataclass\nfrom pathlib import Path\nimport json, csv\nfrom typing import Dict, Any, List\nfrom .file_ops import FileOps, FileOpsConfig\n\n@dataclass\nclass OutputWriter:\n    root: Path\n    def __post_init__(self):\n        self.fo = FileOps(FileOpsConfig())\n        (self.root / \"items\").mkdir(parents=True, exist_ok=True)\n        (self.root / \"batches\").mkdir(exist_ok=True)\n        self._summary = self.root / \"summary.csv\"\n        if not self._summary.exists():\n            with self._summary.open(\"w\", newline=\"\", encoding=\"utf-8\") as f:\n                csv.writer(f).writerow([\"id\",\"path\",\"signature\",\"outfile\",\"ok\",\"error\"])\n\n    def write_item(self, item: Dict[str, Any]) -> Path:\n        p = self.root / \"items\" / f\"{item['id']}.json\"\n        self.fo.write_text(p, json.dumps(item, ensure_ascii=False, indent=2)); return p\n\n    def append_batch(self, items: List[Dict[str, Any]]) -> Path:\n        p = self.root / \"batches\" / \"batches.jsonl\"\n        with p.open(\"a\", encoding=\"utf-8\") as f:\n```\n--\nid: 1680\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\nfrom __future__ import annotations\nfrom dataclasses import dataclass\nfrom pathlib import Path\n\n@dataclass(slots=True)\nclass FileOpsConfig:\n    normalize_newlines: bool = True\n    preserve_crlf: bool = False  # when True, write CRLF instead of LF\n\nclass FileOps:\n    def __init__(self, cfg: FileOpsConfig | None = None):\n        self.cfg = cfg or FileOpsConfig()\n\n    def read_text(self, p: Path) -> str:\n        txt = p.read_text(encoding=\"utf-8\", errors=\"ignore\")\n        return self._norm(txt)\n\n    def write_text(self, p: Path, text: str, *, preserve_crlf: bool | None = None) -> None:\n        \"\"\"Write text, optionally overriding CRLF preservation per call.\"\"\"\n        p.parent.mkdir(parents=True, exist_ok=True)\n        s = self._norm(text)\n        if preserve_crlf is True:\n            s = s.replace(\"\\n\", \"\\r\\n\")\n        elif preserve_crlf is False:\n            # force LF\n            s = s.replace(\"\\r\\n\", \"\\n\").replace(\"\\r\", \"\\n\")\n```\n--\nid: 1679\nmode: create\nsignature: module\ndescription: Write text while optionally preserving CRLF per call.\ncontext_code:\n```python\nfrom __future__ import annotations\nfrom dataclasses import dataclass\nfrom pathlib import Path\n\n@dataclass(slots=True)\nclass FileOpsConfig:\n    normalize_newlines: bool = True\n    preserve_crlf: bool = False  # when True, write CRLF instead of LF\n\nclass FileOps:\n    def __init__(self, cfg: FileOpsConfig | None = None):\n        self.cfg = cfg or FileOpsConfig()\n\n    def read_text(self, p: Path) -> str:\n        txt = p.read_text(encoding=\"utf-8\", errors=\"ignore\")\n        return self._norm(txt)\n\n    def write_text(self, p: Path, text: str, *, preserve_crlf: bool | None = None) -> None:\n        \"\"\"Write text, optionally overriding CRLF preservation per call.\"\"\"\n        p.parent.mkdir(parents=True, exist_ok=True)\n        s = self._norm(text)\n        if preserve_crlf is True:\n            s = s.replace(\"\\n\", \"\\r\\n\")\n        elif preserve_crlf is False:\n            # force LF\n            s = s.replace(\"\\r\\n\", \"\\n\").replace(\"\\r\", \"\\n\")\n```\n--\nid: 1678\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\nfrom __future__ import annotations\nfrom dataclasses import dataclass\nfrom pathlib import Path\n\n@dataclass(slots=True)\nclass FileOpsConfig:\n    normalize_newlines: bool = True\n    preserve_crlf: bool = False  # when True, write CRLF instead of LF\n\nclass FileOps:\n    def __init__(self, cfg: FileOpsConfig | None = None):\n        self.cfg = cfg or FileOpsConfig()\n\n    def read_text(self, p: Path) -> str:\n        txt = p.read_text(encoding=\"utf-8\", errors=\"ignore\")\n        return self._norm(txt)\n\n    def write_text(self, p: Path, text: str, *, preserve_crlf: bool | None = None) -> None:\n        \"\"\"Write text, optionally overriding CRLF preservation per call.\"\"\"\n        p.parent.mkdir(parents=True, exist_ok=True)\n        s = self._norm(text)\n        if preserve_crlf is True:\n            s = s.replace(\"\\n\", \"\\r\\n\")\n        elif preserve_crlf is False:\n            # force LF\n            s = s.replace(\"\\r\\n\", \"\\n\").replace(\"\\r\", \"\\n\")\n```\n--\nid: 1677\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\nfrom __future__ import annotations\nfrom dataclasses import dataclass\nfrom pathlib import Path\n\n@dataclass(slots=True)\nclass FileOpsConfig:\n    normalize_newlines: bool = True\n    preserve_crlf: bool = False  # when True, write CRLF instead of LF\n\nclass FileOps:\n    def __init__(self, cfg: FileOpsConfig | None = None):\n        self.cfg = cfg or FileOpsConfig()\n\n    def read_text(self, p: Path) -> str:\n        txt = p.read_text(encoding=\"utf-8\", errors=\"ignore\")\n        return self._norm(txt)\n\n    def write_text(self, p: Path, text: str, *, preserve_crlf: bool | None = None) -> None:\n        \"\"\"Write text, optionally overriding CRLF preservation per call.\"\"\"\n        p.parent.mkdir(parents=True, exist_ok=True)\n        s = self._norm(text)\n        if preserve_crlf is True:\n            s = s.replace(\"\\n\", \"\\r\\n\")\n        elif preserve_crlf is False:\n            # force LF\n            s = s.replace(\"\\r\\n\", \"\\n\").replace(\"\\r\", \"\\n\")\n```\n--\nid: 1676\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\nfrom __future__ import annotations\nfrom dataclasses import dataclass\nfrom pathlib import Path\n\n@dataclass(slots=True)\nclass FileOpsConfig:\n    normalize_newlines: bool = True\n    preserve_crlf: bool = False  # when True, write CRLF instead of LF\n\nclass FileOps:\n    def __init__(self, cfg: FileOpsConfig | None = None):\n        self.cfg = cfg or FileOpsConfig()\n\n    def read_text(self, p: Path) -> str:\n        txt = p.read_text(encoding=\"utf-8\", errors=\"ignore\")\n        return self._norm(txt)\n\n    def write_text(self, p: Path, text: str, *, preserve_crlf: bool | None = None) -> None:\n        \"\"\"Write text, optionally overriding CRLF preservation per call.\"\"\"\n        p.parent.mkdir(parents=True, exist_ok=True)\n        s = self._norm(text)\n        if preserve_crlf is True:\n            s = s.replace(\"\\n\", \"\\r\\n\")\n        elif preserve_crlf is False:\n            # force LF\n            s = s.replace(\"\\r\\n\", \"\\n\").replace(\"\\r\", \"\\n\")\n```\n--\nid: 1675\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\nfrom __future__ import annotations\nfrom dataclasses import dataclass\nfrom pathlib import Path\n\n@dataclass(slots=True)\nclass FileOpsConfig:\n    normalize_newlines: bool = True\n    preserve_crlf: bool = False  # when True, write CRLF instead of LF\n\nclass FileOps:\n    def __init__(self, cfg: FileOpsConfig | None = None):\n        self.cfg = cfg or FileOpsConfig()\n\n    def read_text(self, p: Path) -> str:\n        txt = p.read_text(encoding=\"utf-8\", errors=\"ignore\")\n        return self._norm(txt)\n\n    def write_text(self, p: Path, text: str, *, preserve_crlf: bool | None = None) -> None:\n        \"\"\"Write text, optionally overriding CRLF preservation per call.\"\"\"\n        p.parent.mkdir(parents=True, exist_ok=True)\n        s = self._norm(text)\n        if preserve_crlf is True:\n            s = s.replace(\"\\n\", \"\\r\\n\")\n        elif preserve_crlf is False:\n            # force LF\n            s = s.replace(\"\\r\\n\", \"\\n\").replace(\"\\r\", \"\\n\")\n```\n--\nid: 1674\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\nimport os\nimport requests\nfrom pathlib import Path\nfrom tqdm import tqdm\nfrom secret_management.secrets_loader import get_secret\n\n# === CONFIGURATION ===\n\nROOT = Path(r\"/software\")\n\nHF_TOKEN = get_secret(\"hugging_face\", default=\"\")  # looks in secret_management/, then ~/.config/packager/  # <<< INSERT YOUR HF TOKEN HERE\nHEADERS = {\"Authorization\": f\"Bearer {HF_TOKEN}\"}\n\nDIR_STRUCTURE = {\n    \"ai_models/mistral\": {\n        \"urls\": [\n            (\n                \"https://huggingface.co/TheBloke/Mistral-7B-Instruct-GGUF/resolve/main/mistral-7b-instruct-v0.1.Q4_K_M.gguf\",\n                \"mistral-7b-instruct-v0.1.Q4_K_M.gguf\"\n            ),\n            (\n                \"https://huggingface.co/mistralai/Mistral-7B-Instruct-v0.1/resolve/main/tokenizer.model\",\n                \"tokenizer.model\"\n            )\n        ]\n    },\n```\n--\nid: 1673\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\nimport os\nimport requests\nfrom pathlib import Path\nfrom tqdm import tqdm\nfrom secret_management.secrets_loader import get_secret\n\n# === CONFIGURATION ===\n\nROOT = Path(r\"/software\")\n\nHF_TOKEN = get_secret(\"hugging_face\", default=\"\")  # looks in secret_management/, then ~/.config/packager/  # <<< INSERT YOUR HF TOKEN HERE\nHEADERS = {\"Authorization\": f\"Bearer {HF_TOKEN}\"}\n\nDIR_STRUCTURE = {\n    \"ai_models/mistral\": {\n        \"urls\": [\n            (\n                \"https://huggingface.co/TheBloke/Mistral-7B-Instruct-GGUF/resolve/main/mistral-7b-instruct-v0.1.Q4_K_M.gguf\",\n                \"mistral-7b-instruct-v0.1.Q4_K_M.gguf\"\n            ),\n            (\n                \"https://huggingface.co/mistralai/Mistral-7B-Instruct-v0.1/resolve/main/tokenizer.model\",\n                \"tokenizer.model\"\n            )\n        ]\n    },\n```\n--\nid: 1672\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\nimport os\nimport requests\nfrom pathlib import Path\nfrom tqdm import tqdm\nfrom secret_management.secrets_loader import get_secret\n\n# === CONFIGURATION ===\n\nROOT = Path(r\"/software\")\n\nHF_TOKEN = get_secret(\"hugging_face\", default=\"\")  # looks in secret_management/, then ~/.config/packager/  # <<< INSERT YOUR HF TOKEN HERE\nHEADERS = {\"Authorization\": f\"Bearer {HF_TOKEN}\"}\n\nDIR_STRUCTURE = {\n    \"ai_models/mistral\": {\n        \"urls\": [\n            (\n                \"https://huggingface.co/TheBloke/Mistral-7B-Instruct-GGUF/resolve/main/mistral-7b-instruct-v0.1.Q4_K_M.gguf\",\n                \"mistral-7b-instruct-v0.1.Q4_K_M.gguf\"\n            ),\n            (\n                \"https://huggingface.co/mistralai/Mistral-7B-Instruct-v0.1/resolve/main/tokenizer.model\",\n                \"tokenizer.model\"\n            )\n        ]\n    },\n```\n--\nid: 1671\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\nimport subprocess\nimport sqlite3\nimport os\nimport sys\nimport runpy\nimport tkinter as tk\nfrom tkinter import messagebox\n\nclass SQLiteWebWrapperGUI:\n    def __init__(self):\n        # ✅ Hardcode your SQLite DB path here:\n        self.db_path = \"C:\\\\Users\\\\cg371\\\\PycharmProjects\\\\ChatGPT Bot\\\\databases\\\\bot_dev.db\"\n        self.tables = []\n        sys.argv = [\"sqlite_web\", self.db_path]\n\n        if not os.path.exists(self.db_path):\n            messagebox.showerror(\"Error\", f\"Database file not found:\\n{self.db_path}\")\n            sys.exit(1)\n\n    def list_tables(self):\n        \"\"\"Retrieve all table names in the selected DB.\"\"\"\n        conn = sqlite3.connect(self.db_path)\n        cursor = conn.cursor()\n        cursor.execute(\n            \"SELECT name FROM sqlite_master WHERE type='table' ORDER BY name;\"\n        )\n```\n--\nid: 1670\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\nimport subprocess\nimport sqlite3\nimport os\nimport sys\nimport runpy\nimport tkinter as tk\nfrom tkinter import messagebox\n\nclass SQLiteWebWrapperGUI:\n    def __init__(self):\n        # ✅ Hardcode your SQLite DB path here:\n        self.db_path = \"C:\\\\Users\\\\cg371\\\\PycharmProjects\\\\ChatGPT Bot\\\\databases\\\\bot_dev.db\"\n        self.tables = []\n        sys.argv = [\"sqlite_web\", self.db_path]\n\n        if not os.path.exists(self.db_path):\n            messagebox.showerror(\"Error\", f\"Database file not found:\\n{self.db_path}\")\n            sys.exit(1)\n\n    def list_tables(self):\n        \"\"\"Retrieve all table names in the selected DB.\"\"\"\n        conn = sqlite3.connect(self.db_path)\n        cursor = conn.cursor()\n        cursor.execute(\n            \"SELECT name FROM sqlite_master WHERE type='table' ORDER BY name;\"\n        )\n```\n--\nid: 1669\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\nimport subprocess\nimport sqlite3\nimport os\nimport sys\nimport runpy\nimport tkinter as tk\nfrom tkinter import messagebox\n\nclass SQLiteWebWrapperGUI:\n    def __init__(self):\n        # ✅ Hardcode your SQLite DB path here:\n        self.db_path = \"C:\\\\Users\\\\cg371\\\\PycharmProjects\\\\ChatGPT Bot\\\\databases\\\\bot_dev.db\"\n        self.tables = []\n        sys.argv = [\"sqlite_web\", self.db_path]\n\n        if not os.path.exists(self.db_path):\n            messagebox.showerror(\"Error\", f\"Database file not found:\\n{self.db_path}\")\n            sys.exit(1)\n\n    def list_tables(self):\n        \"\"\"Retrieve all table names in the selected DB.\"\"\"\n        conn = sqlite3.connect(self.db_path)\n        cursor = conn.cursor()\n        cursor.execute(\n            \"SELECT name FROM sqlite_master WHERE type='table' ORDER BY name;\"\n        )\n```\n--\nid: 1668\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\nimport subprocess\nimport sqlite3\nimport os\nimport sys\nimport runpy\nimport tkinter as tk\nfrom tkinter import messagebox\n\nclass SQLiteWebWrapperGUI:\n    def __init__(self):\n        # ✅ Hardcode your SQLite DB path here:\n        self.db_path = \"C:\\\\Users\\\\cg371\\\\PycharmProjects\\\\ChatGPT Bot\\\\databases\\\\bot_dev.db\"\n        self.tables = []\n        sys.argv = [\"sqlite_web\", self.db_path]\n\n        if not os.path.exists(self.db_path):\n            messagebox.showerror(\"Error\", f\"Database file not found:\\n{self.db_path}\")\n            sys.exit(1)\n\n    def list_tables(self):\n        \"\"\"Retrieve all table names in the selected DB.\"\"\"\n        conn = sqlite3.connect(self.db_path)\n        cursor = conn.cursor()\n        cursor.execute(\n            \"SELECT name FROM sqlite_master WHERE type='table' ORDER BY name;\"\n        )\n```\n--\nid: 1667\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\nimport subprocess\nimport sqlite3\nimport os\nimport sys\nimport runpy\nimport tkinter as tk\nfrom tkinter import messagebox\n\nclass SQLiteWebWrapperGUI:\n    def __init__(self):\n        # ✅ Hardcode your SQLite DB path here:\n        self.db_path = \"C:\\\\Users\\\\cg371\\\\PycharmProjects\\\\ChatGPT Bot\\\\databases\\\\bot_dev.db\"\n        self.tables = []\n        sys.argv = [\"sqlite_web\", self.db_path]\n\n        if not os.path.exists(self.db_path):\n            messagebox.showerror(\"Error\", f\"Database file not found:\\n{self.db_path}\")\n            sys.exit(1)\n\n    def list_tables(self):\n        \"\"\"Retrieve all table names in the selected DB.\"\"\"\n        conn = sqlite3.connect(self.db_path)\n        cursor = conn.cursor()\n        cursor.execute(\n            \"SELECT name FROM sqlite_master WHERE type='table' ORDER BY name;\"\n        )\n```\n--\nid: 1666\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\nimport subprocess\nimport sqlite3\nimport os\nimport sys\nimport runpy\nimport tkinter as tk\nfrom tkinter import messagebox\n\nclass SQLiteWebWrapperGUI:\n    def __init__(self):\n        # ✅ Hardcode your SQLite DB path here:\n        self.db_path = \"C:\\\\Users\\\\cg371\\\\PycharmProjects\\\\ChatGPT Bot\\\\databases\\\\bot_dev.db\"\n        self.tables = []\n        sys.argv = [\"sqlite_web\", self.db_path]\n\n        if not os.path.exists(self.db_path):\n            messagebox.showerror(\"Error\", f\"Database file not found:\\n{self.db_path}\")\n            sys.exit(1)\n\n    def list_tables(self):\n        \"\"\"Retrieve all table names in the selected DB.\"\"\"\n        conn = sqlite3.connect(self.db_path)\n        cursor = conn.cursor()\n        cursor.execute(\n            \"SELECT name FROM sqlite_master WHERE type='table' ORDER BY name;\"\n        )\n```\n--\nid: 1665\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\nimport subprocess\nimport sqlite3\nimport os\nimport sys\nimport runpy\nimport tkinter as tk\nfrom tkinter import messagebox\n\nclass SQLiteWebWrapperGUI:\n    def __init__(self):\n        # ✅ Hardcode your SQLite DB path here:\n        self.db_path = \"C:\\\\Users\\\\cg371\\\\PycharmProjects\\\\ChatGPT Bot\\\\databases\\\\bot_dev.db\"\n        self.tables = []\n        sys.argv = [\"sqlite_web\", self.db_path]\n\n        if not os.path.exists(self.db_path):\n            messagebox.showerror(\"Error\", f\"Database file not found:\\n{self.db_path}\")\n            sys.exit(1)\n\n    def list_tables(self):\n        \"\"\"Retrieve all table names in the selected DB.\"\"\"\n        conn = sqlite3.connect(self.db_path)\n        cursor = conn.cursor()\n        cursor.execute(\n            \"SELECT name FROM sqlite_master WHERE type='table' ORDER BY name;\"\n        )\n```\n--\nid: 1664\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\nfrom __future__ import annotations\nimport sys, io, os, json, zipfile, tarfile, sqlite3 as _stdlib_sqlite3, urllib.request, urllib.error, subprocess\nfrom pathlib import Path\nfrom typing import Optional, Tuple, List\n\n# ---- Repo-aware path resolution (fix leading \"\\\" issue on Windows) -----------\n\nHERE = Path(__file__).resolve()\nPARENTS = list(HERE.parents)\ntry:\n    _DEFAULT_REPO_ROOT = PARENTS[5]  # …/ChatGPT Bot/\nexcept IndexError:\n    _DEFAULT_REPO_ROOT = PARENTS[-1]\n\nREPO_ROOT = Path(os.getenv(\"REPO_ROOT\", str(_DEFAULT_REPO_ROOT))).resolve()\n\ndef _abs_repo(pathlike: str | Path) -> Path:\n    \"\"\"\n    Resolve a path relative to the repo root unless it's a true absolute path.\n    Treat leading '\\' or '/' without drive (Windows) as repo-relative, not drive root.\n    \"\"\"\n    s = str(pathlike)\n    # Windows: \"\\foo\\bar\" -> repo-relative\n    if os.name == \"nt\" and (s.startswith(\"\\\\\") or s.startswith(\"/\")) and not (len(s) >= 2 and s[1] == \":\"):\n        return (REPO_ROOT / s.lstrip(\"\\\\/\")).resolve()\n    p = Path(s)\n```\n--\nid: 1663\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\nfrom __future__ import annotations\nimport sys, io, os, json, zipfile, tarfile, sqlite3 as _stdlib_sqlite3, urllib.request, urllib.error, subprocess\nfrom pathlib import Path\nfrom typing import Optional, Tuple, List\n\n# ---- Repo-aware path resolution (fix leading \"\\\" issue on Windows) -----------\n\nHERE = Path(__file__).resolve()\nPARENTS = list(HERE.parents)\ntry:\n    _DEFAULT_REPO_ROOT = PARENTS[5]  # …/ChatGPT Bot/\nexcept IndexError:\n    _DEFAULT_REPO_ROOT = PARENTS[-1]\n\nREPO_ROOT = Path(os.getenv(\"REPO_ROOT\", str(_DEFAULT_REPO_ROOT))).resolve()\n\ndef _abs_repo(pathlike: str | Path) -> Path:\n    \"\"\"\n    Resolve a path relative to the repo root unless it's a true absolute path.\n    Treat leading '\\' or '/' without drive (Windows) as repo-relative, not drive root.\n    \"\"\"\n    s = str(pathlike)\n    # Windows: \"\\foo\\bar\" -> repo-relative\n    if os.name == \"nt\" and (s.startswith(\"\\\\\") or s.startswith(\"/\")) and not (len(s) >= 2 and s[1] == \":\"):\n        return (REPO_ROOT / s.lstrip(\"\\\\/\")).resolve()\n    p = Path(s)\n```\n--\nid: 1662\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\nfrom __future__ import annotations\nimport sys, io, os, json, zipfile, tarfile, sqlite3 as _stdlib_sqlite3, urllib.request, urllib.error, subprocess\nfrom pathlib import Path\nfrom typing import Optional, Tuple, List\n\n# ---- Repo-aware path resolution (fix leading \"\\\" issue on Windows) -----------\n\nHERE = Path(__file__).resolve()\nPARENTS = list(HERE.parents)\ntry:\n    _DEFAULT_REPO_ROOT = PARENTS[5]  # …/ChatGPT Bot/\nexcept IndexError:\n    _DEFAULT_REPO_ROOT = PARENTS[-1]\n\nREPO_ROOT = Path(os.getenv(\"REPO_ROOT\", str(_DEFAULT_REPO_ROOT))).resolve()\n\ndef _abs_repo(pathlike: str | Path) -> Path:\n    \"\"\"\n    Resolve a path relative to the repo root unless it's a true absolute path.\n    Treat leading '\\' or '/' without drive (Windows) as repo-relative, not drive root.\n    \"\"\"\n    s = str(pathlike)\n    # Windows: \"\\foo\\bar\" -> repo-relative\n    if os.name == \"nt\" and (s.startswith(\"\\\\\") or s.startswith(\"/\")) and not (len(s) >= 2 and s[1] == \":\"):\n        return (REPO_ROOT / s.lstrip(\"\\\\/\")).resolve()\n    p = Path(s)\n```\n--\nid: 1661\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\nfrom __future__ import annotations\nimport sys, io, os, json, zipfile, tarfile, sqlite3 as _stdlib_sqlite3, urllib.request, urllib.error, subprocess\nfrom pathlib import Path\nfrom typing import Optional, Tuple, List\n\n# ---- Repo-aware path resolution (fix leading \"\\\" issue on Windows) -----------\n\nHERE = Path(__file__).resolve()\nPARENTS = list(HERE.parents)\ntry:\n    _DEFAULT_REPO_ROOT = PARENTS[5]  # …/ChatGPT Bot/\nexcept IndexError:\n    _DEFAULT_REPO_ROOT = PARENTS[-1]\n\nREPO_ROOT = Path(os.getenv(\"REPO_ROOT\", str(_DEFAULT_REPO_ROOT))).resolve()\n\ndef _abs_repo(pathlike: str | Path) -> Path:\n    \"\"\"\n    Resolve a path relative to the repo root unless it's a true absolute path.\n    Treat leading '\\' or '/' without drive (Windows) as repo-relative, not drive root.\n    \"\"\"\n    s = str(pathlike)\n    # Windows: \"\\foo\\bar\" -> repo-relative\n    if os.name == \"nt\" and (s.startswith(\"\\\\\") or s.startswith(\"/\")) and not (len(s) >= 2 and s[1] == \":\"):\n        return (REPO_ROOT / s.lstrip(\"\\\\/\")).resolve()\n    p = Path(s)\n```\n--\nid: 1660\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\nfrom __future__ import annotations\nimport sys, io, os, json, zipfile, tarfile, sqlite3 as _stdlib_sqlite3, urllib.request, urllib.error, subprocess\nfrom pathlib import Path\nfrom typing import Optional, Tuple, List\n\n# ---- Repo-aware path resolution (fix leading \"\\\" issue on Windows) -----------\n\nHERE = Path(__file__).resolve()\nPARENTS = list(HERE.parents)\ntry:\n    _DEFAULT_REPO_ROOT = PARENTS[5]  # …/ChatGPT Bot/\nexcept IndexError:\n    _DEFAULT_REPO_ROOT = PARENTS[-1]\n\nREPO_ROOT = Path(os.getenv(\"REPO_ROOT\", str(_DEFAULT_REPO_ROOT))).resolve()\n\ndef _abs_repo(pathlike: str | Path) -> Path:\n    \"\"\"\n    Resolve a path relative to the repo root unless it's a true absolute path.\n    Treat leading '\\' or '/' without drive (Windows) as repo-relative, not drive root.\n    \"\"\"\n    s = str(pathlike)\n    # Windows: \"\\foo\\bar\" -> repo-relative\n    if os.name == \"nt\" and (s.startswith(\"\\\\\") or s.startswith(\"/\")) and not (len(s) >= 2 and s[1] == \":\"):\n        return (REPO_ROOT / s.lstrip(\"\\\\/\")).resolve()\n    p = Path(s)\n```\n--\nid: 1659\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\nfrom __future__ import annotations\nimport sys, io, os, json, zipfile, tarfile, sqlite3 as _stdlib_sqlite3, urllib.request, urllib.error, subprocess\nfrom pathlib import Path\nfrom typing import Optional, Tuple, List\n\n# ---- Repo-aware path resolution (fix leading \"\\\" issue on Windows) -----------\n\nHERE = Path(__file__).resolve()\nPARENTS = list(HERE.parents)\ntry:\n    _DEFAULT_REPO_ROOT = PARENTS[5]  # …/ChatGPT Bot/\nexcept IndexError:\n    _DEFAULT_REPO_ROOT = PARENTS[-1]\n\nREPO_ROOT = Path(os.getenv(\"REPO_ROOT\", str(_DEFAULT_REPO_ROOT))).resolve()\n\ndef _abs_repo(pathlike: str | Path) -> Path:\n    \"\"\"\n    Resolve a path relative to the repo root unless it's a true absolute path.\n    Treat leading '\\' or '/' without drive (Windows) as repo-relative, not drive root.\n    \"\"\"\n    s = str(pathlike)\n    # Windows: \"\\foo\\bar\" -> repo-relative\n    if os.name == \"nt\" and (s.startswith(\"\\\\\") or s.startswith(\"/\")) and not (len(s) >= 2 and s[1] == \":\"):\n        return (REPO_ROOT / s.lstrip(\"\\\\/\")).resolve()\n    p = Path(s)\n```\n--\nid: 1658\nmode: create\nsignature: module\ndescription: Returns `(sqlite3_module, dll_dir_for_windows)` using `pysqlite3-binary` for Windows.\ncontext_code:\n```python\nfrom __future__ import annotations\nimport sys, io, os, json, zipfile, tarfile, sqlite3 as _stdlib_sqlite3, urllib.request, urllib.error, subprocess\nfrom pathlib import Path\nfrom typing import Optional, Tuple, List\n\n# ---- Repo-aware path resolution (fix leading \"\\\" issue on Windows) -----------\n\nHERE = Path(__file__).resolve()\nPARENTS = list(HERE.parents)\ntry:\n    _DEFAULT_REPO_ROOT = PARENTS[5]  # …/ChatGPT Bot/\nexcept IndexError:\n    _DEFAULT_REPO_ROOT = PARENTS[-1]\n\nREPO_ROOT = Path(os.getenv(\"REPO_ROOT\", str(_DEFAULT_REPO_ROOT))).resolve()\n\ndef _abs_repo(pathlike: str | Path) -> Path:\n    \"\"\"\n    Resolve a path relative to the repo root unless it's a true absolute path.\n    Treat leading '\\' or '/' without drive (Windows) as repo-relative, not drive root.\n    \"\"\"\n    s = str(pathlike)\n    # Windows: \"\\foo\\bar\" -> repo-relative\n    if os.name == \"nt\" and (s.startswith(\"\\\\\") or s.startswith(\"/\")) and not (len(s) >= 2 and s[1] == \":\"):\n        return (REPO_ROOT / s.lstrip(\"\\\\/\")).resolve()\n    p = Path(s)\n```\n--\nid: 1657\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\nfrom __future__ import annotations\nimport sys, io, os, json, zipfile, tarfile, sqlite3 as _stdlib_sqlite3, urllib.request, urllib.error, subprocess\nfrom pathlib import Path\nfrom typing import Optional, Tuple, List\n\n# ---- Repo-aware path resolution (fix leading \"\\\" issue on Windows) -----------\n\nHERE = Path(__file__).resolve()\nPARENTS = list(HERE.parents)\ntry:\n    _DEFAULT_REPO_ROOT = PARENTS[5]  # …/ChatGPT Bot/\nexcept IndexError:\n    _DEFAULT_REPO_ROOT = PARENTS[-1]\n\nREPO_ROOT = Path(os.getenv(\"REPO_ROOT\", str(_DEFAULT_REPO_ROOT))).resolve()\n\ndef _abs_repo(pathlike: str | Path) -> Path:\n    \"\"\"\n    Resolve a path relative to the repo root unless it's a true absolute path.\n    Treat leading '\\' or '/' without drive (Windows) as repo-relative, not drive root.\n    \"\"\"\n    s = str(pathlike)\n    # Windows: \"\\foo\\bar\" -> repo-relative\n    if os.name == \"nt\" and (s.startswith(\"\\\\\") or s.startswith(\"/\")) and not (len(s) >= 2 and s[1] == \":\"):\n        return (REPO_ROOT / s.lstrip(\"\\\\/\")).resolve()\n    p = Path(s)\n```\n--\nid: 1656\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\nfrom __future__ import annotations\nimport sys, io, os, json, zipfile, tarfile, sqlite3 as _stdlib_sqlite3, urllib.request, urllib.error, subprocess\nfrom pathlib import Path\nfrom typing import Optional, Tuple, List\n\n# ---- Repo-aware path resolution (fix leading \"\\\" issue on Windows) -----------\n\nHERE = Path(__file__).resolve()\nPARENTS = list(HERE.parents)\ntry:\n    _DEFAULT_REPO_ROOT = PARENTS[5]  # …/ChatGPT Bot/\nexcept IndexError:\n    _DEFAULT_REPO_ROOT = PARENTS[-1]\n\nREPO_ROOT = Path(os.getenv(\"REPO_ROOT\", str(_DEFAULT_REPO_ROOT))).resolve()\n\ndef _abs_repo(pathlike: str | Path) -> Path:\n    \"\"\"\n    Resolve a path relative to the repo root unless it's a true absolute path.\n    Treat leading '\\' or '/' without drive (Windows) as repo-relative, not drive root.\n    \"\"\"\n    s = str(pathlike)\n    # Windows: \"\\foo\\bar\" -> repo-relative\n    if os.name == \"nt\" and (s.startswith(\"\\\\\") or s.startswith(\"/\")) and not (len(s) >= 2 and s[1] == \":\"):\n        return (REPO_ROOT / s.lstrip(\"\\\\/\")).resolve()\n    p = Path(s)\n```\n--\nid: 1655\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\nfrom __future__ import annotations\nimport sys, io, os, json, zipfile, tarfile, sqlite3 as _stdlib_sqlite3, urllib.request, urllib.error, subprocess\nfrom pathlib import Path\nfrom typing import Optional, Tuple, List\n\n# ---- Repo-aware path resolution (fix leading \"\\\" issue on Windows) -----------\n\nHERE = Path(__file__).resolve()\nPARENTS = list(HERE.parents)\ntry:\n    _DEFAULT_REPO_ROOT = PARENTS[5]  # …/ChatGPT Bot/\nexcept IndexError:\n    _DEFAULT_REPO_ROOT = PARENTS[-1]\n\nREPO_ROOT = Path(os.getenv(\"REPO_ROOT\", str(_DEFAULT_REPO_ROOT))).resolve()\n\ndef _abs_repo(pathlike: str | Path) -> Path:\n    \"\"\"\n    Resolve a path relative to the repo root unless it's a true absolute path.\n    Treat leading '\\' or '/' without drive (Windows) as repo-relative, not drive root.\n    \"\"\"\n    s = str(pathlike)\n    # Windows: \"\\foo\\bar\" -> repo-relative\n    if os.name == \"nt\" and (s.startswith(\"\\\\\") or s.startswith(\"/\")) and not (len(s) >= 2 and s[1] == \":\"):\n        return (REPO_ROOT / s.lstrip(\"\\\\/\")).resolve()\n    p = Path(s)\n```\n--\nid: 1654\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\nfrom __future__ import annotations\nimport sys, io, os, json, zipfile, tarfile, sqlite3 as _stdlib_sqlite3, urllib.request, urllib.error, subprocess\nfrom pathlib import Path\nfrom typing import Optional, Tuple, List\n\n# ---- Repo-aware path resolution (fix leading \"\\\" issue on Windows) -----------\n\nHERE = Path(__file__).resolve()\nPARENTS = list(HERE.parents)\ntry:\n    _DEFAULT_REPO_ROOT = PARENTS[5]  # …/ChatGPT Bot/\nexcept IndexError:\n    _DEFAULT_REPO_ROOT = PARENTS[-1]\n\nREPO_ROOT = Path(os.getenv(\"REPO_ROOT\", str(_DEFAULT_REPO_ROOT))).resolve()\n\ndef _abs_repo(pathlike: str | Path) -> Path:\n    \"\"\"\n    Resolve a path relative to the repo root unless it's a true absolute path.\n    Treat leading '\\' or '/' without drive (Windows) as repo-relative, not drive root.\n    \"\"\"\n    s = str(pathlike)\n    # Windows: \"\\foo\\bar\" -> repo-relative\n    if os.name == \"nt\" and (s.startswith(\"\\\\\") or s.startswith(\"/\")) and not (len(s) >= 2 and s[1] == \":\"):\n        return (REPO_ROOT / s.lstrip(\"\\\\/\")).resolve()\n    p = Path(s)\n```\n--\nid: 1653\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\nfrom __future__ import annotations\nimport sys, io, os, json, zipfile, tarfile, sqlite3 as _stdlib_sqlite3, urllib.request, urllib.error, subprocess\nfrom pathlib import Path\nfrom typing import Optional, Tuple, List\n\n# ---- Repo-aware path resolution (fix leading \"\\\" issue on Windows) -----------\n\nHERE = Path(__file__).resolve()\nPARENTS = list(HERE.parents)\ntry:\n    _DEFAULT_REPO_ROOT = PARENTS[5]  # …/ChatGPT Bot/\nexcept IndexError:\n    _DEFAULT_REPO_ROOT = PARENTS[-1]\n\nREPO_ROOT = Path(os.getenv(\"REPO_ROOT\", str(_DEFAULT_REPO_ROOT))).resolve()\n\ndef _abs_repo(pathlike: str | Path) -> Path:\n    \"\"\"\n    Resolve a path relative to the repo root unless it's a true absolute path.\n    Treat leading '\\' or '/' without drive (Windows) as repo-relative, not drive root.\n    \"\"\"\n    s = str(pathlike)\n    # Windows: \"\\foo\\bar\" -> repo-relative\n    if os.name == \"nt\" and (s.startswith(\"\\\\\") or s.startswith(\"/\")) and not (len(s) >= 2 and s[1] == \":\"):\n        return (REPO_ROOT / s.lstrip(\"\\\\/\")).resolve()\n    p = Path(s)\n```\n--\nid: 1652\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\nfrom __future__ import annotations\nimport sys, io, os, json, zipfile, tarfile, sqlite3 as _stdlib_sqlite3, urllib.request, urllib.error, subprocess\nfrom pathlib import Path\nfrom typing import Optional, Tuple, List\n\n# ---- Repo-aware path resolution (fix leading \"\\\" issue on Windows) -----------\n\nHERE = Path(__file__).resolve()\nPARENTS = list(HERE.parents)\ntry:\n    _DEFAULT_REPO_ROOT = PARENTS[5]  # …/ChatGPT Bot/\nexcept IndexError:\n    _DEFAULT_REPO_ROOT = PARENTS[-1]\n\nREPO_ROOT = Path(os.getenv(\"REPO_ROOT\", str(_DEFAULT_REPO_ROOT))).resolve()\n\ndef _abs_repo(pathlike: str | Path) -> Path:\n    \"\"\"\n    Resolve a path relative to the repo root unless it's a true absolute path.\n    Treat leading '\\' or '/' without drive (Windows) as repo-relative, not drive root.\n    \"\"\"\n    s = str(pathlike)\n    # Windows: \"\\foo\\bar\" -> repo-relative\n    if os.name == \"nt\" and (s.startswith(\"\\\\\") or s.startswith(\"/\")) and not (len(s) >= 2 and s[1] == \":\"):\n        return (REPO_ROOT / s.lstrip(\"\\\\/\")).resolve()\n    p = Path(s)\n```\n--\nid: 1651\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\nfrom __future__ import annotations\nimport sys, io, os, json, zipfile, tarfile, sqlite3 as _stdlib_sqlite3, urllib.request, urllib.error, subprocess\nfrom pathlib import Path\nfrom typing import Optional, Tuple, List\n\n# ---- Repo-aware path resolution (fix leading \"\\\" issue on Windows) -----------\n\nHERE = Path(__file__).resolve()\nPARENTS = list(HERE.parents)\ntry:\n    _DEFAULT_REPO_ROOT = PARENTS[5]  # …/ChatGPT Bot/\nexcept IndexError:\n    _DEFAULT_REPO_ROOT = PARENTS[-1]\n\nREPO_ROOT = Path(os.getenv(\"REPO_ROOT\", str(_DEFAULT_REPO_ROOT))).resolve()\n\ndef _abs_repo(pathlike: str | Path) -> Path:\n    \"\"\"\n    Resolve a path relative to the repo root unless it's a true absolute path.\n    Treat leading '\\' or '/' without drive (Windows) as repo-relative, not drive root.\n    \"\"\"\n    s = str(pathlike)\n    # Windows: \"\\foo\\bar\" -> repo-relative\n    if os.name == \"nt\" and (s.startswith(\"\\\\\") or s.startswith(\"/\")) and not (len(s) >= 2 and s[1] == \":\"):\n        return (REPO_ROOT / s.lstrip(\"\\\\/\")).resolve()\n    p = Path(s)\n```\n--\nid: 1650\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\nfrom __future__ import annotations\nimport sys, io, os, json, zipfile, tarfile, sqlite3 as _stdlib_sqlite3, urllib.request, urllib.error, subprocess\nfrom pathlib import Path\nfrom typing import Optional, Tuple, List\n\n# ---- Repo-aware path resolution (fix leading \"\\\" issue on Windows) -----------\n\nHERE = Path(__file__).resolve()\nPARENTS = list(HERE.parents)\ntry:\n    _DEFAULT_REPO_ROOT = PARENTS[5]  # …/ChatGPT Bot/\nexcept IndexError:\n    _DEFAULT_REPO_ROOT = PARENTS[-1]\n\nREPO_ROOT = Path(os.getenv(\"REPO_ROOT\", str(_DEFAULT_REPO_ROOT))).resolve()\n\ndef _abs_repo(pathlike: str | Path) -> Path:\n    \"\"\"\n    Resolve a path relative to the repo root unless it's a true absolute path.\n    Treat leading '\\' or '/' without drive (Windows) as repo-relative, not drive root.\n    \"\"\"\n    s = str(pathlike)\n    # Windows: \"\\foo\\bar\" -> repo-relative\n    if os.name == \"nt\" and (s.startswith(\"\\\\\") or s.startswith(\"/\")) and not (len(s) >= 2 and s[1] == \":\"):\n        return (REPO_ROOT / s.lstrip(\"\\\\/\")).resolve()\n    p = Path(s)\n```\n--\nid: 1649\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\nfrom __future__ import annotations\nimport sys, io, os, json, zipfile, tarfile, sqlite3 as _stdlib_sqlite3, urllib.request, urllib.error, subprocess\nfrom pathlib import Path\nfrom typing import Optional, Tuple, List\n\n# ---- Repo-aware path resolution (fix leading \"\\\" issue on Windows) -----------\n\nHERE = Path(__file__).resolve()\nPARENTS = list(HERE.parents)\ntry:\n    _DEFAULT_REPO_ROOT = PARENTS[5]  # …/ChatGPT Bot/\nexcept IndexError:\n    _DEFAULT_REPO_ROOT = PARENTS[-1]\n\nREPO_ROOT = Path(os.getenv(\"REPO_ROOT\", str(_DEFAULT_REPO_ROOT))).resolve()\n\ndef _abs_repo(pathlike: str | Path) -> Path:\n    \"\"\"\n    Resolve a path relative to the repo root unless it's a true absolute path.\n    Treat leading '\\' or '/' without drive (Windows) as repo-relative, not drive root.\n    \"\"\"\n    s = str(pathlike)\n    # Windows: \"\\foo\\bar\" -> repo-relative\n    if os.name == \"nt\" and (s.startswith(\"\\\\\") or s.startswith(\"/\")) and not (len(s) >= 2 and s[1] == \":\"):\n        return (REPO_ROOT / s.lstrip(\"\\\\/\")).resolve()\n    p = Path(s)\n```\n--\nid: 1648\nmode: create\nsignature: module\ndescription: Treat leading '' or '/' without drive as repo-relative, not drive root.\ncontext_code:\n```python\nfrom __future__ import annotations\nimport sys, io, os, json, zipfile, tarfile, sqlite3 as _stdlib_sqlite3, urllib.request, urllib.error, subprocess\nfrom pathlib import Path\nfrom typing import Optional, Tuple, List\n\n# ---- Repo-aware path resolution (fix leading \"\\\" issue on Windows) -----------\n\nHERE = Path(__file__).resolve()\nPARENTS = list(HERE.parents)\ntry:\n    _DEFAULT_REPO_ROOT = PARENTS[5]  # …/ChatGPT Bot/\nexcept IndexError:\n    _DEFAULT_REPO_ROOT = PARENTS[-1]\n\nREPO_ROOT = Path(os.getenv(\"REPO_ROOT\", str(_DEFAULT_REPO_ROOT))).resolve()\n\ndef _abs_repo(pathlike: str | Path) -> Path:\n    \"\"\"\n    Resolve a path relative to the repo root unless it's a true absolute path.\n    Treat leading '\\' or '/' without drive (Windows) as repo-relative, not drive root.\n    \"\"\"\n    s = str(pathlike)\n    # Windows: \"\\foo\\bar\" -> repo-relative\n    if os.name == \"nt\" and (s.startswith(\"\\\\\") or s.startswith(\"/\")) and not (len(s) >= 2 and s[1] == \":\"):\n        return (REPO_ROOT / s.lstrip(\"\\\\/\")).resolve()\n    p = Path(s)\n```\n--\nid: 1647\nmode: rewrite\nsignature: module\ndescription: Initialize SQLite database with SQL scripts from schema_dir.\ncontext_code:\n```python\n#v2/backend/core/utils/db/init_sqlite_dev.py\n\"\"\"\nSQLite development database initializer (YAML-driven, no hardcoded paths).\n\n- Reads DB coordinates and schema directory *strictly* from the centralized loader.\n- Supports only SQLite for this tool; errors clearly if another backend is configured.\n- Applies SQL files in lexicographic order from the configured schema directory.\n- For each SQL file, attempts to parse the primary table name:\n    * If a table name is parsed and the table already exists => skip file.\n    * If no table can be parsed => apply file (best-effort).\n- Strips manual BEGIN/COMMIT in SQL scripts to avoid nested transaction errors.\n\nUsage:\n    python -m v2.backend.core.utils.db.init_sqlite_dev\n\"\"\"\n\nfrom __future__ import annotations\n\nimport re\nimport sqlite3\nfrom pathlib import Path\nfrom typing import Dict, Iterable, List, Optional, Tuple\n\nfrom v2.backend.core.configuration.loader import ConfigError, get_db\n\n\n```\n--\nid: 1646\nmode: rewrite\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n#v2/backend/core/utils/db/init_sqlite_dev.py\n\"\"\"\nSQLite development database initializer (YAML-driven, no hardcoded paths).\n\n- Reads DB coordinates and schema directory *strictly* from the centralized loader.\n- Supports only SQLite for this tool; errors clearly if another backend is configured.\n- Applies SQL files in lexicographic order from the configured schema directory.\n- For each SQL file, attempts to parse the primary table name:\n    * If a table name is parsed and the table already exists => skip file.\n    * If no table can be parsed => apply file (best-effort).\n- Strips manual BEGIN/COMMIT in SQL scripts to avoid nested transaction errors.\n\nUsage:\n    python -m v2.backend.core.utils.db.init_sqlite_dev\n\"\"\"\n\nfrom __future__ import annotations\n\nimport re\nimport sqlite3\nfrom pathlib import Path\nfrom typing import Dict, Iterable, List, Optional, Tuple\n\nfrom v2.backend.core.configuration.loader import ConfigError, get_db\n\n\n```\n--\nid: 1645\nmode: rewrite\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n#v2/backend/core/utils/db/init_sqlite_dev.py\n\"\"\"\nSQLite development database initializer (YAML-driven, no hardcoded paths).\n\n- Reads DB coordinates and schema directory *strictly* from the centralized loader.\n- Supports only SQLite for this tool; errors clearly if another backend is configured.\n- Applies SQL files in lexicographic order from the configured schema directory.\n- For each SQL file, attempts to parse the primary table name:\n    * If a table name is parsed and the table already exists => skip file.\n    * If no table can be parsed => apply file (best-effort).\n- Strips manual BEGIN/COMMIT in SQL scripts to avoid nested transaction errors.\n\nUsage:\n    python -m v2.backend.core.utils.db.init_sqlite_dev\n\"\"\"\n\nfrom __future__ import annotations\n\nimport re\nimport sqlite3\nfrom pathlib import Path\nfrom typing import Dict, Iterable, List, Optional, Tuple\n\nfrom v2.backend.core.configuration.loader import ConfigError, get_db\n\n\n```\n--\nid: 1644\nmode: rewrite\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n#v2/backend/core/utils/db/init_sqlite_dev.py\n\"\"\"\nSQLite development database initializer (YAML-driven, no hardcoded paths).\n\n- Reads DB coordinates and schema directory *strictly* from the centralized loader.\n- Supports only SQLite for this tool; errors clearly if another backend is configured.\n- Applies SQL files in lexicographic order from the configured schema directory.\n- For each SQL file, attempts to parse the primary table name:\n    * If a table name is parsed and the table already exists => skip file.\n    * If no table can be parsed => apply file (best-effort).\n- Strips manual BEGIN/COMMIT in SQL scripts to avoid nested transaction errors.\n\nUsage:\n    python -m v2.backend.core.utils.db.init_sqlite_dev\n\"\"\"\n\nfrom __future__ import annotations\n\nimport re\nimport sqlite3\nfrom pathlib import Path\nfrom typing import Dict, Iterable, List, Optional, Tuple\n\nfrom v2.backend.core.configuration.loader import ConfigError, get_db\n\n\n```\n--\nid: 1643\nmode: rewrite\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n#v2/backend/core/utils/db/init_sqlite_dev.py\n\"\"\"\nSQLite development database initializer (YAML-driven, no hardcoded paths).\n\n- Reads DB coordinates and schema directory *strictly* from the centralized loader.\n- Supports only SQLite for this tool; errors clearly if another backend is configured.\n- Applies SQL files in lexicographic order from the configured schema directory.\n- For each SQL file, attempts to parse the primary table name:\n    * If a table name is parsed and the table already exists => skip file.\n    * If no table can be parsed => apply file (best-effort).\n- Strips manual BEGIN/COMMIT in SQL scripts to avoid nested transaction errors.\n\nUsage:\n    python -m v2.backend.core.utils.db.init_sqlite_dev\n\"\"\"\n\nfrom __future__ import annotations\n\nimport re\nimport sqlite3\nfrom pathlib import Path\nfrom typing import Dict, Iterable, List, Optional, Tuple\n\nfrom v2.backend.core.configuration.loader import ConfigError, get_db\n\n\n```\n--\nid: 1642\nmode: rewrite\nsignature: module\ndescription: A very tolerant parser for creating tables.\ncontext_code:\n```python\n#v2/backend/core/utils/db/init_sqlite_dev.py\n\"\"\"\nSQLite development database initializer (YAML-driven, no hardcoded paths).\n\n- Reads DB coordinates and schema directory *strictly* from the centralized loader.\n- Supports only SQLite for this tool; errors clearly if another backend is configured.\n- Applies SQL files in lexicographic order from the configured schema directory.\n- For each SQL file, attempts to parse the primary table name:\n    * If a table name is parsed and the table already exists => skip file.\n    * If no table can be parsed => apply file (best-effort).\n- Strips manual BEGIN/COMMIT in SQL scripts to avoid nested transaction errors.\n\nUsage:\n    python -m v2.backend.core.utils.db.init_sqlite_dev\n\"\"\"\n\nfrom __future__ import annotations\n\nimport re\nimport sqlite3\nfrom pathlib import Path\nfrom typing import Dict, Iterable, List, Optional, Tuple\n\nfrom v2.backend.core.configuration.loader import ConfigError, get_db\n\n\n```\n--\nid: 1641\nmode: rewrite\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n#v2/backend/core/utils/db/init_sqlite_dev.py\n\"\"\"\nSQLite development database initializer (YAML-driven, no hardcoded paths).\n\n- Reads DB coordinates and schema directory *strictly* from the centralized loader.\n- Supports only SQLite for this tool; errors clearly if another backend is configured.\n- Applies SQL files in lexicographic order from the configured schema directory.\n- For each SQL file, attempts to parse the primary table name:\n    * If a table name is parsed and the table already exists => skip file.\n    * If no table can be parsed => apply file (best-effort).\n- Strips manual BEGIN/COMMIT in SQL scripts to avoid nested transaction errors.\n\nUsage:\n    python -m v2.backend.core.utils.db.init_sqlite_dev\n\"\"\"\n\nfrom __future__ import annotations\n\nimport re\nimport sqlite3\nfrom pathlib import Path\nfrom typing import Dict, Iterable, List, Optional, Tuple\n\nfrom v2.backend.core.configuration.loader import ConfigError, get_db\n\n\n```\n--\nid: 1640\nmode: rewrite\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n#v2/backend/core/utils/db/init_sqlite_dev.py\n\"\"\"\nSQLite development database initializer (YAML-driven, no hardcoded paths).\n\n- Reads DB coordinates and schema directory *strictly* from the centralized loader.\n- Supports only SQLite for this tool; errors clearly if another backend is configured.\n- Applies SQL files in lexicographic order from the configured schema directory.\n- For each SQL file, attempts to parse the primary table name:\n    * If a table name is parsed and the table already exists => skip file.\n    * If no table can be parsed => apply file (best-effort).\n- Strips manual BEGIN/COMMIT in SQL scripts to avoid nested transaction errors.\n\nUsage:\n    python -m v2.backend.core.utils.db.init_sqlite_dev\n\"\"\"\n\nfrom __future__ import annotations\n\nimport re\nimport sqlite3\nfrom pathlib import Path\nfrom typing import Dict, Iterable, List, Optional, Tuple\n\nfrom v2.backend.core.configuration.loader import ConfigError, get_db\n\n\n```\n--\nid: 1639\nmode: rewrite\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n#v2/backend/core/utils/db/init_sqlite_dev.py\n\"\"\"\nSQLite development database initializer (YAML-driven, no hardcoded paths).\n\n- Reads DB coordinates and schema directory *strictly* from the centralized loader.\n- Supports only SQLite for this tool; errors clearly if another backend is configured.\n- Applies SQL files in lexicographic order from the configured schema directory.\n- For each SQL file, attempts to parse the primary table name:\n    * If a table name is parsed and the table already exists => skip file.\n    * If no table can be parsed => apply file (best-effort).\n- Strips manual BEGIN/COMMIT in SQL scripts to avoid nested transaction errors.\n\nUsage:\n    python -m v2.backend.core.utils.db.init_sqlite_dev\n\"\"\"\n\nfrom __future__ import annotations\n\nimport re\nimport sqlite3\nfrom pathlib import Path\nfrom typing import Dict, Iterable, List, Optional, Tuple\n\nfrom v2.backend.core.configuration.loader import ConfigError, get_db\n\n\n```\n--\nid: 1638\nmode: rewrite\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n#v2/backend/core/utils/db/init_sqlite_dev.py\n\"\"\"\nSQLite development database initializer (YAML-driven, no hardcoded paths).\n\n- Reads DB coordinates and schema directory *strictly* from the centralized loader.\n- Supports only SQLite for this tool; errors clearly if another backend is configured.\n- Applies SQL files in lexicographic order from the configured schema directory.\n- For each SQL file, attempts to parse the primary table name:\n    * If a table name is parsed and the table already exists => skip file.\n    * If no table can be parsed => apply file (best-effort).\n- Strips manual BEGIN/COMMIT in SQL scripts to avoid nested transaction errors.\n\nUsage:\n    python -m v2.backend.core.utils.db.init_sqlite_dev\n\"\"\"\n\nfrom __future__ import annotations\n\nimport re\nimport sqlite3\nfrom pathlib import Path\nfrom typing import Dict, Iterable, List, Optional, Tuple\n\nfrom v2.backend.core.configuration.loader import ConfigError, get_db\n\n\n```\n--\nid: 1637\nmode: rewrite\nsignature: module\ndescription: `init_sqlite_dev` initializes an SQLite development database by reading coordinates and schema files from the centralized loader, and applying SQL files in lexicographic order.\ncontext_code:\n```python\n#v2/backend/core/utils/db/init_sqlite_dev.py\n\"\"\"\nSQLite development database initializer (YAML-driven, no hardcoded paths).\n\n- Reads DB coordinates and schema directory *strictly* from the centralized loader.\n- Supports only SQLite for this tool; errors clearly if another backend is configured.\n- Applies SQL files in lexicographic order from the configured schema directory.\n- For each SQL file, attempts to parse the primary table name:\n    * If a table name is parsed and the table already exists => skip file.\n    * If no table can be parsed => apply file (best-effort).\n- Strips manual BEGIN/COMMIT in SQL scripts to avoid nested transaction errors.\n\nUsage:\n    python -m v2.backend.core.utils.db.init_sqlite_dev\n\"\"\"\n\nfrom __future__ import annotations\n\nimport re\nimport sqlite3\nfrom pathlib import Path\nfrom typing import Dict, Iterable, List, Optional, Tuple\n\nfrom v2.backend.core.configuration.loader import ConfigError, get_db\n\n\n```\n--\nid: 1636\nmode: rewrite\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n\"\"\"Filesystem IO helpers.\"\"\"\n```\n--\nid: 1635\nmode: rewrite\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n#!/usr/bin/env python3\n\"\"\"\nimport_refactor.py — class-based import refactoring by mapping.\n\nUsage (programmatic):\n    mapping = {\n        \"backend.core.prompt_pipeline.executor.rewrite\": \"patches.core.rewrite\",\n        \"backend.core.utils.io.patch_ops\": \"patches.core.patch_ops\",\n    }\n    r = ImportRefactor(mapping, root=\".\", include_globs=(\"**/*.py\",), exclude_globs=(\"**/.venv/**\",))\n    report = r.run(dry_run=True)  # or dry_run=False for in-place edit\n    print(report.summary())\n\nDesign notes:\n- Only refactors ABSOLUTE imports (level == 0). Relative imports are left untouched.\n- Handles:\n    import a.b.c as x, d.e\n    from a.b import c as x, d\n- For `from M import N`, if mapping contains the FULLY-QUALIFIED \"M.N\" → \"X.Y\", it rewrites to:\n    from X import Y\n- Prefix matching is supported: if name startswith old + \".\", it's rewritten with the same suffix.\n- Preserves file encoding and newline style; reconstructs only the changed import lines.\n\nLimitations:\n- Multi-line imports are reconstructed as a single logical import line (functionally equivalent).\n- If a single `from ... import ...` line would need to split across multiple new modules,\n```\n--\nid: 1634\nmode: rewrite\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n#!/usr/bin/env python3\n\"\"\"\nimport_refactor.py — class-based import refactoring by mapping.\n\nUsage (programmatic):\n    mapping = {\n        \"backend.core.prompt_pipeline.executor.rewrite\": \"patches.core.rewrite\",\n        \"backend.core.utils.io.patch_ops\": \"patches.core.patch_ops\",\n    }\n    r = ImportRefactor(mapping, root=\".\", include_globs=(\"**/*.py\",), exclude_globs=(\"**/.venv/**\",))\n    report = r.run(dry_run=True)  # or dry_run=False for in-place edit\n    print(report.summary())\n\nDesign notes:\n- Only refactors ABSOLUTE imports (level == 0). Relative imports are left untouched.\n- Handles:\n    import a.b.c as x, d.e\n    from a.b import c as x, d\n- For `from M import N`, if mapping contains the FULLY-QUALIFIED \"M.N\" → \"X.Y\", it rewrites to:\n    from X import Y\n- Prefix matching is supported: if name startswith old + \".\", it's rewritten with the same suffix.\n- Preserves file encoding and newline style; reconstructs only the changed import lines.\n\nLimitations:\n- Multi-line imports are reconstructed as a single logical import line (functionally equivalent).\n- If a single `from ... import ...` line would need to split across multiple new modules,\n```\n--\nid: 1633\nmode: rewrite\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n#!/usr/bin/env python3\n\"\"\"\nimport_refactor.py — class-based import refactoring by mapping.\n\nUsage (programmatic):\n    mapping = {\n        \"backend.core.prompt_pipeline.executor.rewrite\": \"patches.core.rewrite\",\n        \"backend.core.utils.io.patch_ops\": \"patches.core.patch_ops\",\n    }\n    r = ImportRefactor(mapping, root=\".\", include_globs=(\"**/*.py\",), exclude_globs=(\"**/.venv/**\",))\n    report = r.run(dry_run=True)  # or dry_run=False for in-place edit\n    print(report.summary())\n\nDesign notes:\n- Only refactors ABSOLUTE imports (level == 0). Relative imports are left untouched.\n- Handles:\n    import a.b.c as x, d.e\n    from a.b import c as x, d\n- For `from M import N`, if mapping contains the FULLY-QUALIFIED \"M.N\" → \"X.Y\", it rewrites to:\n    from X import Y\n- Prefix matching is supported: if name startswith old + \".\", it's rewritten with the same suffix.\n- Preserves file encoding and newline style; reconstructs only the changed import lines.\n\nLimitations:\n- Multi-line imports are reconstructed as a single logical import line (functionally equivalent).\n- If a single `from ... import ...` line would need to split across multiple new modules,\n```\n--\nid: 1632\nmode: rewrite\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n#!/usr/bin/env python3\n\"\"\"\nimport_refactor.py — class-based import refactoring by mapping.\n\nUsage (programmatic):\n    mapping = {\n        \"backend.core.prompt_pipeline.executor.rewrite\": \"patches.core.rewrite\",\n        \"backend.core.utils.io.patch_ops\": \"patches.core.patch_ops\",\n    }\n    r = ImportRefactor(mapping, root=\".\", include_globs=(\"**/*.py\",), exclude_globs=(\"**/.venv/**\",))\n    report = r.run(dry_run=True)  # or dry_run=False for in-place edit\n    print(report.summary())\n\nDesign notes:\n- Only refactors ABSOLUTE imports (level == 0). Relative imports are left untouched.\n- Handles:\n    import a.b.c as x, d.e\n    from a.b import c as x, d\n- For `from M import N`, if mapping contains the FULLY-QUALIFIED \"M.N\" → \"X.Y\", it rewrites to:\n    from X import Y\n- Prefix matching is supported: if name startswith old + \".\", it's rewritten with the same suffix.\n- Preserves file encoding and newline style; reconstructs only the changed import lines.\n\nLimitations:\n- Multi-line imports are reconstructed as a single logical import line (functionally equivalent).\n- If a single `from ... import ...` line would need to split across multiple new modules,\n```\n--\nid: 1631\nmode: rewrite\nsignature: module\ndescription: Apply mapping to a dotted qualname with longest-key wins and support for exact and prefix matches.\ncontext_code:\n```python\n#!/usr/bin/env python3\n\"\"\"\nimport_refactor.py — class-based import refactoring by mapping.\n\nUsage (programmatic):\n    mapping = {\n        \"backend.core.prompt_pipeline.executor.rewrite\": \"patches.core.rewrite\",\n        \"backend.core.utils.io.patch_ops\": \"patches.core.patch_ops\",\n    }\n    r = ImportRefactor(mapping, root=\".\", include_globs=(\"**/*.py\",), exclude_globs=(\"**/.venv/**\",))\n    report = r.run(dry_run=True)  # or dry_run=False for in-place edit\n    print(report.summary())\n\nDesign notes:\n- Only refactors ABSOLUTE imports (level == 0). Relative imports are left untouched.\n- Handles:\n    import a.b.c as x, d.e\n    from a.b import c as x, d\n- For `from M import N`, if mapping contains the FULLY-QUALIFIED \"M.N\" → \"X.Y\", it rewrites to:\n    from X import Y\n- Prefix matching is supported: if name startswith old + \".\", it's rewritten with the same suffix.\n- Preserves file encoding and newline style; reconstructs only the changed import lines.\n\nLimitations:\n- Multi-line imports are reconstructed as a single logical import line (functionally equivalent).\n- If a single `from ... import ...` line would need to split across multiple new modules,\n```\n--\nid: 1630\nmode: rewrite\nsignature: module\ndescription: Try module-level remapping before per-alias mapping with full name.\ncontext_code:\n```python\n#!/usr/bin/env python3\n\"\"\"\nimport_refactor.py — class-based import refactoring by mapping.\n\nUsage (programmatic):\n    mapping = {\n        \"backend.core.prompt_pipeline.executor.rewrite\": \"patches.core.rewrite\",\n        \"backend.core.utils.io.patch_ops\": \"patches.core.patch_ops\",\n    }\n    r = ImportRefactor(mapping, root=\".\", include_globs=(\"**/*.py\",), exclude_globs=(\"**/.venv/**\",))\n    report = r.run(dry_run=True)  # or dry_run=False for in-place edit\n    print(report.summary())\n\nDesign notes:\n- Only refactors ABSOLUTE imports (level == 0). Relative imports are left untouched.\n- Handles:\n    import a.b.c as x, d.e\n    from a.b import c as x, d\n- For `from M import N`, if mapping contains the FULLY-QUALIFIED \"M.N\" → \"X.Y\", it rewrites to:\n    from X import Y\n- Prefix matching is supported: if name startswith old + \".\", it's rewritten with the same suffix.\n- Preserves file encoding and newline style; reconstructs only the changed import lines.\n\nLimitations:\n- Multi-line imports are reconstructed as a single logical import line (functionally equivalent).\n- If a single `from ... import ...` line would need to split across multiple new modules,\n```\n--\nid: 1629\nmode: rewrite\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n#!/usr/bin/env python3\n\"\"\"\nimport_refactor.py — class-based import refactoring by mapping.\n\nUsage (programmatic):\n    mapping = {\n        \"backend.core.prompt_pipeline.executor.rewrite\": \"patches.core.rewrite\",\n        \"backend.core.utils.io.patch_ops\": \"patches.core.patch_ops\",\n    }\n    r = ImportRefactor(mapping, root=\".\", include_globs=(\"**/*.py\",), exclude_globs=(\"**/.venv/**\",))\n    report = r.run(dry_run=True)  # or dry_run=False for in-place edit\n    print(report.summary())\n\nDesign notes:\n- Only refactors ABSOLUTE imports (level == 0). Relative imports are left untouched.\n- Handles:\n    import a.b.c as x, d.e\n    from a.b import c as x, d\n- For `from M import N`, if mapping contains the FULLY-QUALIFIED \"M.N\" → \"X.Y\", it rewrites to:\n    from X import Y\n- Prefix matching is supported: if name startswith old + \".\", it's rewritten with the same suffix.\n- Preserves file encoding and newline style; reconstructs only the changed import lines.\n\nLimitations:\n- Multi-line imports are reconstructed as a single logical import line (functionally equivalent).\n- If a single `from ... import ...` line would need to split across multiple new modules,\n```\n--\nid: 1628\nmode: rewrite\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n#!/usr/bin/env python3\n\"\"\"\nimport_refactor.py — class-based import refactoring by mapping.\n\nUsage (programmatic):\n    mapping = {\n        \"backend.core.prompt_pipeline.executor.rewrite\": \"patches.core.rewrite\",\n        \"backend.core.utils.io.patch_ops\": \"patches.core.patch_ops\",\n    }\n    r = ImportRefactor(mapping, root=\".\", include_globs=(\"**/*.py\",), exclude_globs=(\"**/.venv/**\",))\n    report = r.run(dry_run=True)  # or dry_run=False for in-place edit\n    print(report.summary())\n\nDesign notes:\n- Only refactors ABSOLUTE imports (level == 0). Relative imports are left untouched.\n- Handles:\n    import a.b.c as x, d.e\n    from a.b import c as x, d\n- For `from M import N`, if mapping contains the FULLY-QUALIFIED \"M.N\" → \"X.Y\", it rewrites to:\n    from X import Y\n- Prefix matching is supported: if name startswith old + \".\", it's rewritten with the same suffix.\n- Preserves file encoding and newline style; reconstructs only the changed import lines.\n\nLimitations:\n- Multi-line imports are reconstructed as a single logical import line (functionally equivalent).\n- If a single `from ... import ...` line would need to split across multiple new modules,\n```\n--\nid: 1627\nmode: rewrite\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n#!/usr/bin/env python3\n\"\"\"\nimport_refactor.py — class-based import refactoring by mapping.\n\nUsage (programmatic):\n    mapping = {\n        \"backend.core.prompt_pipeline.executor.rewrite\": \"patches.core.rewrite\",\n        \"backend.core.utils.io.patch_ops\": \"patches.core.patch_ops\",\n    }\n    r = ImportRefactor(mapping, root=\".\", include_globs=(\"**/*.py\",), exclude_globs=(\"**/.venv/**\",))\n    report = r.run(dry_run=True)  # or dry_run=False for in-place edit\n    print(report.summary())\n\nDesign notes:\n- Only refactors ABSOLUTE imports (level == 0). Relative imports are left untouched.\n- Handles:\n    import a.b.c as x, d.e\n    from a.b import c as x, d\n- For `from M import N`, if mapping contains the FULLY-QUALIFIED \"M.N\" → \"X.Y\", it rewrites to:\n    from X import Y\n- Prefix matching is supported: if name startswith old + \".\", it's rewritten with the same suffix.\n- Preserves file encoding and newline style; reconstructs only the changed import lines.\n\nLimitations:\n- Multi-line imports are reconstructed as a single logical import line (functionally equivalent).\n- If a single `from ... import ...` line would need to split across multiple new modules,\n```\n--\nid: 1626\nmode: rewrite\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n#!/usr/bin/env python3\n\"\"\"\nimport_refactor.py — class-based import refactoring by mapping.\n\nUsage (programmatic):\n    mapping = {\n        \"backend.core.prompt_pipeline.executor.rewrite\": \"patches.core.rewrite\",\n        \"backend.core.utils.io.patch_ops\": \"patches.core.patch_ops\",\n    }\n    r = ImportRefactor(mapping, root=\".\", include_globs=(\"**/*.py\",), exclude_globs=(\"**/.venv/**\",))\n    report = r.run(dry_run=True)  # or dry_run=False for in-place edit\n    print(report.summary())\n\nDesign notes:\n- Only refactors ABSOLUTE imports (level == 0). Relative imports are left untouched.\n- Handles:\n    import a.b.c as x, d.e\n    from a.b import c as x, d\n- For `from M import N`, if mapping contains the FULLY-QUALIFIED \"M.N\" → \"X.Y\", it rewrites to:\n    from X import Y\n- Prefix matching is supported: if name startswith old + \".\", it's rewritten with the same suffix.\n- Preserves file encoding and newline style; reconstructs only the changed import lines.\n\nLimitations:\n- Multi-line imports are reconstructed as a single logical import line (functionally equivalent).\n- If a single `from ... import ...` line would need to split across multiple new modules,\n```\n--\nid: 1625\nmode: rewrite\nsignature: module\ndescription: Map old module paths to new module paths in given root directory, including or excluding certain file globs, and with optional prefix matching and backup suffix. The encoding parameter is also specified.\ncontext_code:\n```python\n#!/usr/bin/env python3\n\"\"\"\nimport_refactor.py — class-based import refactoring by mapping.\n\nUsage (programmatic):\n    mapping = {\n        \"backend.core.prompt_pipeline.executor.rewrite\": \"patches.core.rewrite\",\n        \"backend.core.utils.io.patch_ops\": \"patches.core.patch_ops\",\n    }\n    r = ImportRefactor(mapping, root=\".\", include_globs=(\"**/*.py\",), exclude_globs=(\"**/.venv/**\",))\n    report = r.run(dry_run=True)  # or dry_run=False for in-place edit\n    print(report.summary())\n\nDesign notes:\n- Only refactors ABSOLUTE imports (level == 0). Relative imports are left untouched.\n- Handles:\n    import a.b.c as x, d.e\n    from a.b import c as x, d\n- For `from M import N`, if mapping contains the FULLY-QUALIFIED \"M.N\" → \"X.Y\", it rewrites to:\n    from X import Y\n- Prefix matching is supported: if name startswith old + \".\", it's rewritten with the same suffix.\n- Preserves file encoding and newline style; reconstructs only the changed import lines.\n\nLimitations:\n- Multi-line imports are reconstructed as a single logical import line (functionally equivalent).\n- If a single `from ... import ...` line would need to split across multiple new modules,\n```\n--\nid: 1624\nmode: rewrite\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n#!/usr/bin/env python3\n\"\"\"\nimport_refactor.py — class-based import refactoring by mapping.\n\nUsage (programmatic):\n    mapping = {\n        \"backend.core.prompt_pipeline.executor.rewrite\": \"patches.core.rewrite\",\n        \"backend.core.utils.io.patch_ops\": \"patches.core.patch_ops\",\n    }\n    r = ImportRefactor(mapping, root=\".\", include_globs=(\"**/*.py\",), exclude_globs=(\"**/.venv/**\",))\n    report = r.run(dry_run=True)  # or dry_run=False for in-place edit\n    print(report.summary())\n\nDesign notes:\n- Only refactors ABSOLUTE imports (level == 0). Relative imports are left untouched.\n- Handles:\n    import a.b.c as x, d.e\n    from a.b import c as x, d\n- For `from M import N`, if mapping contains the FULLY-QUALIFIED \"M.N\" → \"X.Y\", it rewrites to:\n    from X import Y\n- Prefix matching is supported: if name startswith old + \".\", it's rewritten with the same suffix.\n- Preserves file encoding and newline style; reconstructs only the changed import lines.\n\nLimitations:\n- Multi-line imports are reconstructed as a single logical import line (functionally equivalent).\n- If a single `from ... import ...` line would need to split across multiple new modules,\n```\n--\nid: 1623\nmode: rewrite\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n#!/usr/bin/env python3\n\"\"\"\nimport_refactor.py — class-based import refactoring by mapping.\n\nUsage (programmatic):\n    mapping = {\n        \"backend.core.prompt_pipeline.executor.rewrite\": \"patches.core.rewrite\",\n        \"backend.core.utils.io.patch_ops\": \"patches.core.patch_ops\",\n    }\n    r = ImportRefactor(mapping, root=\".\", include_globs=(\"**/*.py\",), exclude_globs=(\"**/.venv/**\",))\n    report = r.run(dry_run=True)  # or dry_run=False for in-place edit\n    print(report.summary())\n\nDesign notes:\n- Only refactors ABSOLUTE imports (level == 0). Relative imports are left untouched.\n- Handles:\n    import a.b.c as x, d.e\n    from a.b import c as x, d\n- For `from M import N`, if mapping contains the FULLY-QUALIFIED \"M.N\" → \"X.Y\", it rewrites to:\n    from X import Y\n- Prefix matching is supported: if name startswith old + \".\", it's rewritten with the same suffix.\n- Preserves file encoding and newline style; reconstructs only the changed import lines.\n\nLimitations:\n- Multi-line imports are reconstructed as a single logical import line (functionally equivalent).\n- If a single `from ... import ...` line would need to split across multiple new modules,\n```\n--\nid: 1622\nmode: rewrite\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n#!/usr/bin/env python3\n\"\"\"\nimport_refactor.py — class-based import refactoring by mapping.\n\nUsage (programmatic):\n    mapping = {\n        \"backend.core.prompt_pipeline.executor.rewrite\": \"patches.core.rewrite\",\n        \"backend.core.utils.io.patch_ops\": \"patches.core.patch_ops\",\n    }\n    r = ImportRefactor(mapping, root=\".\", include_globs=(\"**/*.py\",), exclude_globs=(\"**/.venv/**\",))\n    report = r.run(dry_run=True)  # or dry_run=False for in-place edit\n    print(report.summary())\n\nDesign notes:\n- Only refactors ABSOLUTE imports (level == 0). Relative imports are left untouched.\n- Handles:\n    import a.b.c as x, d.e\n    from a.b import c as x, d\n- For `from M import N`, if mapping contains the FULLY-QUALIFIED \"M.N\" → \"X.Y\", it rewrites to:\n    from X import Y\n- Prefix matching is supported: if name startswith old + \".\", it's rewritten with the same suffix.\n- Preserves file encoding and newline style; reconstructs only the changed import lines.\n\nLimitations:\n- Multi-line imports are reconstructed as a single logical import line (functionally equivalent).\n- If a single `from ... import ...` line would need to split across multiple new modules,\n```\n--\nid: 1621\nmode: rewrite\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n#!/usr/bin/env python3\n\"\"\"\nimport_refactor.py — class-based import refactoring by mapping.\n\nUsage (programmatic):\n    mapping = {\n        \"backend.core.prompt_pipeline.executor.rewrite\": \"patches.core.rewrite\",\n        \"backend.core.utils.io.patch_ops\": \"patches.core.patch_ops\",\n    }\n    r = ImportRefactor(mapping, root=\".\", include_globs=(\"**/*.py\",), exclude_globs=(\"**/.venv/**\",))\n    report = r.run(dry_run=True)  # or dry_run=False for in-place edit\n    print(report.summary())\n\nDesign notes:\n- Only refactors ABSOLUTE imports (level == 0). Relative imports are left untouched.\n- Handles:\n    import a.b.c as x, d.e\n    from a.b import c as x, d\n- For `from M import N`, if mapping contains the FULLY-QUALIFIED \"M.N\" → \"X.Y\", it rewrites to:\n    from X import Y\n- Prefix matching is supported: if name startswith old + \".\", it's rewritten with the same suffix.\n- Preserves file encoding and newline style; reconstructs only the changed import lines.\n\nLimitations:\n- Multi-line imports are reconstructed as a single logical import line (functionally equivalent).\n- If a single `from ... import ...` line would need to split across multiple new modules,\n```\n--\nid: 1620\nmode: rewrite\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n#!/usr/bin/env python3\n\"\"\"\nimport_refactor.py — class-based import refactoring by mapping.\n\nUsage (programmatic):\n    mapping = {\n        \"backend.core.prompt_pipeline.executor.rewrite\": \"patches.core.rewrite\",\n        \"backend.core.utils.io.patch_ops\": \"patches.core.patch_ops\",\n    }\n    r = ImportRefactor(mapping, root=\".\", include_globs=(\"**/*.py\",), exclude_globs=(\"**/.venv/**\",))\n    report = r.run(dry_run=True)  # or dry_run=False for in-place edit\n    print(report.summary())\n\nDesign notes:\n- Only refactors ABSOLUTE imports (level == 0). Relative imports are left untouched.\n- Handles:\n    import a.b.c as x, d.e\n    from a.b import c as x, d\n- For `from M import N`, if mapping contains the FULLY-QUALIFIED \"M.N\" → \"X.Y\", it rewrites to:\n    from X import Y\n- Prefix matching is supported: if name startswith old + \".\", it's rewritten with the same suffix.\n- Preserves file encoding and newline style; reconstructs only the changed import lines.\n\nLimitations:\n- Multi-line imports are reconstructed as a single logical import line (functionally equivalent).\n- If a single `from ... import ...` line would need to split across multiple new modules,\n```\n--\nid: 1619\nmode: rewrite\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n#!/usr/bin/env python3\n\"\"\"\nimport_refactor.py — class-based import refactoring by mapping.\n\nUsage (programmatic):\n    mapping = {\n        \"backend.core.prompt_pipeline.executor.rewrite\": \"patches.core.rewrite\",\n        \"backend.core.utils.io.patch_ops\": \"patches.core.patch_ops\",\n    }\n    r = ImportRefactor(mapping, root=\".\", include_globs=(\"**/*.py\",), exclude_globs=(\"**/.venv/**\",))\n    report = r.run(dry_run=True)  # or dry_run=False for in-place edit\n    print(report.summary())\n\nDesign notes:\n- Only refactors ABSOLUTE imports (level == 0). Relative imports are left untouched.\n- Handles:\n    import a.b.c as x, d.e\n    from a.b import c as x, d\n- For `from M import N`, if mapping contains the FULLY-QUALIFIED \"M.N\" → \"X.Y\", it rewrites to:\n    from X import Y\n- Prefix matching is supported: if name startswith old + \".\", it's rewritten with the same suffix.\n- Preserves file encoding and newline style; reconstructs only the changed import lines.\n\nLimitations:\n- Multi-line imports are reconstructed as a single logical import line (functionally equivalent).\n- If a single `from ... import ...` line would need to split across multiple new modules,\n```\n--\nid: 1618\nmode: rewrite\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n#!/usr/bin/env python3\n\"\"\"\nimport_refactor.py — class-based import refactoring by mapping.\n\nUsage (programmatic):\n    mapping = {\n        \"backend.core.prompt_pipeline.executor.rewrite\": \"patches.core.rewrite\",\n        \"backend.core.utils.io.patch_ops\": \"patches.core.patch_ops\",\n    }\n    r = ImportRefactor(mapping, root=\".\", include_globs=(\"**/*.py\",), exclude_globs=(\"**/.venv/**\",))\n    report = r.run(dry_run=True)  # or dry_run=False for in-place edit\n    print(report.summary())\n\nDesign notes:\n- Only refactors ABSOLUTE imports (level == 0). Relative imports are left untouched.\n- Handles:\n    import a.b.c as x, d.e\n    from a.b import c as x, d\n- For `from M import N`, if mapping contains the FULLY-QUALIFIED \"M.N\" → \"X.Y\", it rewrites to:\n    from X import Y\n- Prefix matching is supported: if name startswith old + \".\", it's rewritten with the same suffix.\n- Preserves file encoding and newline style; reconstructs only the changed import lines.\n\nLimitations:\n- Multi-line imports are reconstructed as a single logical import line (functionally equivalent).\n- If a single `from ... import ...` line would need to split across multiple new modules,\n```\n--\nid: 1617\nmode: rewrite\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n#!/usr/bin/env python3\n\"\"\"\nimport_refactor.py — class-based import refactoring by mapping.\n\nUsage (programmatic):\n    mapping = {\n        \"backend.core.prompt_pipeline.executor.rewrite\": \"patches.core.rewrite\",\n        \"backend.core.utils.io.patch_ops\": \"patches.core.patch_ops\",\n    }\n    r = ImportRefactor(mapping, root=\".\", include_globs=(\"**/*.py\",), exclude_globs=(\"**/.venv/**\",))\n    report = r.run(dry_run=True)  # or dry_run=False for in-place edit\n    print(report.summary())\n\nDesign notes:\n- Only refactors ABSOLUTE imports (level == 0). Relative imports are left untouched.\n- Handles:\n    import a.b.c as x, d.e\n    from a.b import c as x, d\n- For `from M import N`, if mapping contains the FULLY-QUALIFIED \"M.N\" → \"X.Y\", it rewrites to:\n    from X import Y\n- Prefix matching is supported: if name startswith old + \".\", it's rewritten with the same suffix.\n- Preserves file encoding and newline style; reconstructs only the changed import lines.\n\nLimitations:\n- Multi-line imports are reconstructed as a single logical import line (functionally equivalent).\n- If a single `from ... import ...` line would need to split across multiple new modules,\n```\n--\nid: 1616\nmode: rewrite\nsignature: module\ndescription: Class-based import refactoring by mapping in Python.\ncontext_code:\n```python\n#!/usr/bin/env python3\n\"\"\"\nimport_refactor.py — class-based import refactoring by mapping.\n\nUsage (programmatic):\n    mapping = {\n        \"backend.core.prompt_pipeline.executor.rewrite\": \"patches.core.rewrite\",\n        \"backend.core.utils.io.patch_ops\": \"patches.core.patch_ops\",\n    }\n    r = ImportRefactor(mapping, root=\".\", include_globs=(\"**/*.py\",), exclude_globs=(\"**/.venv/**\",))\n    report = r.run(dry_run=True)  # or dry_run=False for in-place edit\n    print(report.summary())\n\nDesign notes:\n- Only refactors ABSOLUTE imports (level == 0). Relative imports are left untouched.\n- Handles:\n    import a.b.c as x, d.e\n    from a.b import c as x, d\n- For `from M import N`, if mapping contains the FULLY-QUALIFIED \"M.N\" → \"X.Y\", it rewrites to:\n    from X import Y\n- Prefix matching is supported: if name startswith old + \".\", it's rewritten with the same suffix.\n- Preserves file encoding and newline style; reconstructs only the changed import lines.\n\nLimitations:\n- Multi-line imports are reconstructed as a single logical import line (functionally equivalent).\n- If a single `from ... import ...` line would need to split across multiple new modules,\n```\n--\nid: 1615\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n#!/usr/bin/env python3\nfrom __future__ import annotations\nimport base64, hashlib, json\nfrom pathlib import Path\n\n# -------- hardcoded config (yours) --------\nINPUT_BUNDLE = r\"C:\\Users\\cg371\\PycharmProjects\\ChatGPT Bot\\tests_adhoc\\output\\downloaded_code_bundles\\class_based_source_bundle_20250816_222801.jsonl\"\nDEST_ROOT   = Path(r\"C:\\Users\\cg371\\PycharmProjects\\ChatGPT Bot\\tests_adhoc\\output\\downloaded_code_bundles\").resolve()\nSTRICT = False\n# -----------------------------------------\n\ndef sha256_bytes(b: bytes) -> str:\n    return hashlib.sha256(b).hexdigest()\n\ndef ensure_relative_safe(rel: str) -> Path:\n    p = Path(rel.replace(\"\\\\\", \"/\"))\n    if p.is_absolute(): raise ValueError(f\"absolute path not allowed: {rel}\")\n    if any(part == \"..\" for part in p.parts): raise ValueError(f\"parent traversal not allowed: {rel}\")\n    if p.parts and p.parts[0].endswith(\":\"): raise ValueError(f\"drive-qualified path not allowed: {rel}\")\n    return p\n\ndef detect_bundle_type(path: Path) -> str:\n    head = path.read_bytes()[:512]\n    if head.startswith(b\"PK\\x03\\x04\"): return \"zip\"\n    txt = head.decode(\"utf-8\", errors=\"ignore\").lstrip(\"\\ufeff\").lstrip()\n    if txt.startswith(\"{\"): return \"jsonl\"\n```\n--\nid: 1614\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n#!/usr/bin/env python3\nfrom __future__ import annotations\nimport base64, hashlib, json\nfrom pathlib import Path\n\n# -------- hardcoded config (yours) --------\nINPUT_BUNDLE = r\"C:\\Users\\cg371\\PycharmProjects\\ChatGPT Bot\\tests_adhoc\\output\\downloaded_code_bundles\\class_based_source_bundle_20250816_222801.jsonl\"\nDEST_ROOT   = Path(r\"C:\\Users\\cg371\\PycharmProjects\\ChatGPT Bot\\tests_adhoc\\output\\downloaded_code_bundles\").resolve()\nSTRICT = False\n# -----------------------------------------\n\ndef sha256_bytes(b: bytes) -> str:\n    return hashlib.sha256(b).hexdigest()\n\ndef ensure_relative_safe(rel: str) -> Path:\n    p = Path(rel.replace(\"\\\\\", \"/\"))\n    if p.is_absolute(): raise ValueError(f\"absolute path not allowed: {rel}\")\n    if any(part == \"..\" for part in p.parts): raise ValueError(f\"parent traversal not allowed: {rel}\")\n    if p.parts and p.parts[0].endswith(\":\"): raise ValueError(f\"drive-qualified path not allowed: {rel}\")\n    return p\n\ndef detect_bundle_type(path: Path) -> str:\n    head = path.read_bytes()[:512]\n    if head.startswith(b\"PK\\x03\\x04\"): return \"zip\"\n    txt = head.decode(\"utf-8\", errors=\"ignore\").lstrip(\"\\ufeff\").lstrip()\n    if txt.startswith(\"{\"): return \"jsonl\"\n```\n--\nid: 1613\nmode: create\nsignature: module\ndescription: Scan for balanced braces in strings and yield JSON object strings.\ncontext_code:\n```python\n#!/usr/bin/env python3\nfrom __future__ import annotations\nimport base64, hashlib, json\nfrom pathlib import Path\n\n# -------- hardcoded config (yours) --------\nINPUT_BUNDLE = r\"C:\\Users\\cg371\\PycharmProjects\\ChatGPT Bot\\tests_adhoc\\output\\downloaded_code_bundles\\class_based_source_bundle_20250816_222801.jsonl\"\nDEST_ROOT   = Path(r\"C:\\Users\\cg371\\PycharmProjects\\ChatGPT Bot\\tests_adhoc\\output\\downloaded_code_bundles\").resolve()\nSTRICT = False\n# -----------------------------------------\n\ndef sha256_bytes(b: bytes) -> str:\n    return hashlib.sha256(b).hexdigest()\n\ndef ensure_relative_safe(rel: str) -> Path:\n    p = Path(rel.replace(\"\\\\\", \"/\"))\n    if p.is_absolute(): raise ValueError(f\"absolute path not allowed: {rel}\")\n    if any(part == \"..\" for part in p.parts): raise ValueError(f\"parent traversal not allowed: {rel}\")\n    if p.parts and p.parts[0].endswith(\":\"): raise ValueError(f\"drive-qualified path not allowed: {rel}\")\n    return p\n\ndef detect_bundle_type(path: Path) -> str:\n    head = path.read_bytes()[:512]\n    if head.startswith(b\"PK\\x03\\x04\"): return \"zip\"\n    txt = head.decode(\"utf-8\", errors=\"ignore\").lstrip(\"\\ufeff\").lstrip()\n    if txt.startswith(\"{\"): return \"jsonl\"\n```\n--\nid: 1612\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n#!/usr/bin/env python3\nfrom __future__ import annotations\nimport base64, hashlib, json\nfrom pathlib import Path\n\n# -------- hardcoded config (yours) --------\nINPUT_BUNDLE = r\"C:\\Users\\cg371\\PycharmProjects\\ChatGPT Bot\\tests_adhoc\\output\\downloaded_code_bundles\\class_based_source_bundle_20250816_222801.jsonl\"\nDEST_ROOT   = Path(r\"C:\\Users\\cg371\\PycharmProjects\\ChatGPT Bot\\tests_adhoc\\output\\downloaded_code_bundles\").resolve()\nSTRICT = False\n# -----------------------------------------\n\ndef sha256_bytes(b: bytes) -> str:\n    return hashlib.sha256(b).hexdigest()\n\ndef ensure_relative_safe(rel: str) -> Path:\n    p = Path(rel.replace(\"\\\\\", \"/\"))\n    if p.is_absolute(): raise ValueError(f\"absolute path not allowed: {rel}\")\n    if any(part == \"..\" for part in p.parts): raise ValueError(f\"parent traversal not allowed: {rel}\")\n    if p.parts and p.parts[0].endswith(\":\"): raise ValueError(f\"drive-qualified path not allowed: {rel}\")\n    return p\n\ndef detect_bundle_type(path: Path) -> str:\n    head = path.read_bytes()[:512]\n    if head.startswith(b\"PK\\x03\\x04\"): return \"zip\"\n    txt = head.decode(\"utf-8\", errors=\"ignore\").lstrip(\"\\ufeff\").lstrip()\n    if txt.startswith(\"{\"): return \"jsonl\"\n```\n--\nid: 1611\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n#!/usr/bin/env python3\nfrom __future__ import annotations\nimport base64, hashlib, json\nfrom pathlib import Path\n\n# -------- hardcoded config (yours) --------\nINPUT_BUNDLE = r\"C:\\Users\\cg371\\PycharmProjects\\ChatGPT Bot\\tests_adhoc\\output\\downloaded_code_bundles\\class_based_source_bundle_20250816_222801.jsonl\"\nDEST_ROOT   = Path(r\"C:\\Users\\cg371\\PycharmProjects\\ChatGPT Bot\\tests_adhoc\\output\\downloaded_code_bundles\").resolve()\nSTRICT = False\n# -----------------------------------------\n\ndef sha256_bytes(b: bytes) -> str:\n    return hashlib.sha256(b).hexdigest()\n\ndef ensure_relative_safe(rel: str) -> Path:\n    p = Path(rel.replace(\"\\\\\", \"/\"))\n    if p.is_absolute(): raise ValueError(f\"absolute path not allowed: {rel}\")\n    if any(part == \"..\" for part in p.parts): raise ValueError(f\"parent traversal not allowed: {rel}\")\n    if p.parts and p.parts[0].endswith(\":\"): raise ValueError(f\"drive-qualified path not allowed: {rel}\")\n    return p\n\ndef detect_bundle_type(path: Path) -> str:\n    head = path.read_bytes()[:512]\n    if head.startswith(b\"PK\\x03\\x04\"): return \"zip\"\n    txt = head.decode(\"utf-8\", errors=\"ignore\").lstrip(\"\\ufeff\").lstrip()\n    if txt.startswith(\"{\"): return \"jsonl\"\n```\n--\nid: 1610\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\n#!/usr/bin/env python3\nfrom __future__ import annotations\nimport base64, hashlib, json\nfrom pathlib import Path\n\n# -------- hardcoded config (yours) --------\nINPUT_BUNDLE = r\"C:\\Users\\cg371\\PycharmProjects\\ChatGPT Bot\\tests_adhoc\\output\\downloaded_code_bundles\\class_based_source_bundle_20250816_222801.jsonl\"\nDEST_ROOT   = Path(r\"C:\\Users\\cg371\\PycharmProjects\\ChatGPT Bot\\tests_adhoc\\output\\downloaded_code_bundles\").resolve()\nSTRICT = False\n# -----------------------------------------\n\ndef sha256_bytes(b: bytes) -> str:\n    return hashlib.sha256(b).hexdigest()\n\ndef ensure_relative_safe(rel: str) -> Path:\n    p = Path(rel.replace(\"\\\\\", \"/\"))\n    if p.is_absolute(): raise ValueError(f\"absolute path not allowed: {rel}\")\n    if any(part == \"..\" for part in p.parts): raise ValueError(f\"parent traversal not allowed: {rel}\")\n    if p.parts and p.parts[0].endswith(\":\"): raise ValueError(f\"drive-qualified path not allowed: {rel}\")\n    return p\n\ndef detect_bundle_type(path: Path) -> str:\n    head = path.read_bytes()[:512]\n    if head.startswith(b\"PK\\x03\\x04\"): return \"zip\"\n    txt = head.decode(\"utf-8\", errors=\"ignore\").lstrip(\"\\ufeff\").lstrip()\n    if txt.startswith(\"{\"): return \"jsonl\"\n```\n--\nid: 1609\nmode: create\nsignature: module\ndescription: Bad docstring\ncontext_code:\n```python\nfrom __future__ import annotations\nimport base64, hashlib, json, sys\nfrom pathlib import Path\n\n#ROOT = Path(__file__).resolve().parents[1] / \"tests_adhoc\" / \"patch_loop_test2\"   # adjust if needed\n#OUT  = Path(__file__).resolve().parents[0] / \"output\" / \"code_bundles\"/ \"code_bundle.jsonl\"\n#SUMS = Path(__file__).resolve().parents[0] / \"output\" / \"code_bundles\"/ \"code_bundle.SHA256SUMS\"\n\nROOT = Path(\"C:\\\\Users\\\\cg371\\\\PycharmProjects\\\\ChatGPT Bot\\\\v2\\\\backend\\\\core\\\\utils\\\\code_bundles\\\\code_bundles\\\\\")   # adjust if needed\nOUT  = Path(\"/output/output_code_bundles\\\\code_bundle.jsonl\")\nSUMS = Path(\"/output/output_code_bundles\\\\code_bundle.SHA256SUMS\")\n\nEXCLUDE_DIRS = {\".git\", \"__pycache__\", \".mypy_cache\", \".pytest_cache\", \"output\", \"dist\", \"build\", \".venv\", \"venv\"}\nEXCLUDE_EXTS = {\".pyc\", \".pyo\", \".pyd\", \".log\"}\n\ndef sha256_bytes(data: bytes) -> str:\n    return hashlib.sha256(data).hexdigest()\n\ndef main():\n    root = ROOT\n    files = []\n    for p in root.rglob(\"*\"):\n        if p.is_dir():\n            if p.name in EXCLUDE_DIRS:\n                continue\n            # skip excluded ancestors\n```\n\nReturn ONLY the JSON list as the entire response."
    }
  ],
  "ask_spec": {},
  "batch_id": 1807
}